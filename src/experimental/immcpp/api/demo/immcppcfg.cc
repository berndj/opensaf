/*      -*- OpenSAF  -*-
 *
 * Copyright Ericsson AB 2017 - All Rights Reserved.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Ericsson AB
 *
 */
#include "experimental/immcpp/api/demo/immcppcfg.h"

#include <unistd.h>
#include <getopt.h>
#include <signal.h>

#include <iostream>
#include <vector>
#include <string>
#include "experimental/immcpp/api/include/om_handle.h"
#include "experimental/immcpp/api/include/om_class_description_get.h"
#include "experimental/immcpp/api/include/om_ccb_handle.h"
#include "experimental/immcpp/api/include/om_ccb_object_create.h"
#include "experimental/immcpp/api/include/om_ccb_object_delete.h"
#include "experimental/immcpp/api/include/om_admin_owner_handle.h"
#include "experimental/immcpp/api/include/om_admin_owner_set.h"
#include "experimental/immcpp/api/include/om_admin_owner_clear.h"
#include "experimental/immcpp/api/include/om_accessor_handle.h"
#include "experimental/immcpp/api/include/om_accessor_get.h"
#include "experimental/immcpp/api/include/om_class_delete.h"
#include "base/saf_error.h"
#include "base/osaf_extended_name.h"


SaVersionT imm_version = {'A', 2, 17};
bool verbose = false;
bool ccb_safe = true;

#define VERBOSE_INFO(format, args...)   \
  if (verbose) {                        \
    fprintf(stderr, format, ##args);    \
  }

const SaImmCcbFlagsT KDefCcbFlags =
    SA_IMM_CCB_REGISTERED_OI | SA_IMM_CCB_ALLOW_NULL_OI;

static void usage(const char *progname) {
  printf("\nNAME\n");
  printf("\t%s - create, delete or modify IMM configuration object(s)\n",
         progname);

  printf("\nSYNOPSIS\n");
  printf("\t%s [options] [object DN]...\n", progname);

  printf("\nDESCRIPTION\n");
  printf("\t%s is an IMM OM client used to create, delete an IMM or modify "
         "attribute(s) for IMM object(s)\n", progname);
  printf("\tThe default operation if none specified is modify.\n");
  printf("\tWhen creating or modifying several objects, they have to be of the "
      "same class.\n");
  printf("\timmcppcfg command has the same syntax as immcfg in the command "
      "line. For example: \"immcfg -d safAmfNode=Node01,safAmfCluster=1\"\n");

  printf("\nOPTIONS\n");
  printf("\t-a, --attribute name[+|-]=value [object DN]... \n");
  printf("\t-c, --create-object <class name> [object DN]... \n");
  printf("\t-d, --delete-object [object DN]... \n");
  printf("\t-h, --help                    this help\n");
  printf("\t-m, --modify-object [object DN]... \n");
  printf("\t-v, --verbose information\n");
  printf("\t-t, --timeout <sec>\n");
  printf("\t\tutility timeout in seconds\n");
  printf("\t--delete-class <classname> [classname2]... \n");
  printf("\t--class-name <classname> [attribute name]...\n");
  printf("\t-u, --unsafe\n");
  printf("\t-o, --admin-owner <admin owner name> \n");
  printf("\t--admin-owner-clear [object DN]\n");

  printf("\nEXAMPLE\n");
  printf("\timmcppcfg -a saAmfNodeSuFailoverMax=7 "
      "safAmfNode=Node01,safAmfCluster=1\n");
  printf("\t\tchange one attribute for one object\n");
  printf("\timmcppcfg -c SaAmfApplication "
      "-a saAmfAppType=Test safApp=myTestApp1\n");
  printf("\t\tcreate one object setting one initialized attribute\n");
  printf("\timmcppcfg -c class -a attrMulti=one -a attrMulti=two obj=1\n");
  printf("\t\tcreate object with multiple values for MULTI_VALUE attribute\n");
  printf("\timmcppcfg -a attrMulti=three -a attrMulti=four obj=1\n");
  printf("\t\tModify object with multiple values for MULTI_VALUE attribute\n");
  printf("\timmcppcfg -d safAmfNode=Node01,safAmfCluster=1\n");
  printf("\t\tdelete one object\n");
  printf("\timmcppcfg -d safAmfNode=Node01,safAmfCluster=1 "
         "safAmfNode=Node02,safAmfCluster=1\n");
  printf("\t\tdelete two objects\n");
  printf("\timmcppcfg -a saAmfNGNodeList+=safAmfNode=PL_2_6,safAmfCluster="
      "myAmfCluster safAmfNodeGroup=PLs,safAmfCluster=myAmfCluster\n");
  printf("\t\tadd a value to an attribute\n");
  printf("\timmcppcfg -a saAmfNGNodeList-=safAmfNode=PL_2_6,safAmfCluster="
      "myAmfCluster safAmfNodeGroup=PLs,safAmfCluster=myAmfCluster\n");
  printf("\t\tremove a value from an attribute\n");
  printf("\timmcppcfg -u .....\n");

  printf("\t\tThe CCBs generated by immcppcfg will has SA_IMM_CCB_REGISTERED_OI"
      " set to false, allowing ccb commit when OIs are missing\n");

  printf("\timmcppcfg -o myAdminOwner -a saAmfNodeSuFailoverMax=7 safAmfNode="
      "Node01,safAmfCluster=1\n");
  printf("\t\tuse 'myAdminOwnerName' as admin owner name for changing one "
      "attribute of one object\n");
  printf("\timmcppcfg --admin-owner-clear safAmfNode=Node01,safAmfCluster=1\n");
  printf("\t\tclear admin owner from one object\n");
}

// Signal handler for SIGALRM
static void sigalarmh(int sig) {
  fprintf(stderr, "error - immcfg command timed out (alarm)\n");
  exit(EXIT_FAILURE);
}

static CfgOperationT VerifySetOption(
    CfgOperationT prevValue, CfgOperationT newValue) {
  if (prevValue == KInvalidOperation) {
    return newValue;
  } else {
    fprintf(stderr, "Error - Only one operation at a time supported\n");
    exit(EXIT_FAILURE);
  }
}

static char *CreateAdminOwnerName(char *base) {
  char hostname[_POSIX_HOST_NAME_MAX];
  char *unique_admin_owner =
      new char[_POSIX_HOST_NAME_MAX + 10 + strlen(base) + 5]();

  if (gethostname(hostname, sizeof(hostname)) != 0) {
    fprintf(stderr, "error while retrieving hostname\n");
    delete[] unique_admin_owner;
      return nullptr;
  }
  snprintf(unique_admin_owner, _POSIX_HOST_NAME_MAX + 15 + strlen(base),
           "%s_%s_%d", base, hostname, getpid());

  return unique_admin_owner;
}

// Constructor
ImmCppCfg::ImmCppCfg() :
    attributes_list_{},
    objects_info_list_{},
    om_handle_{nullptr},
    admin_owner_handle_{nullptr} {}

// Destructor
ImmCppCfg::~ImmCppCfg() {
  for (auto a : attributes_list_) FreeAttribute(a);

  for (auto obj : objects_info_list_) {
    FreeAttribute(obj->rdn);
    delete obj;
  }

  if (admin_owner_handle_ != nullptr) delete admin_owner_handle_;
  if (om_handle_ != nullptr) delete om_handle_;
}

void ImmCppCfg::SetNewAttribute(
    immom::ImmOmCcbObjectCreate *ccb_object, AttributeInfoT *attribute) {
  assert(ccb_object != nullptr);
  switch (attribute->type) {
    case SA_IMM_ATTR_SAINT32T: {
      std::vector<SaInt32T*> *value =
          reinterpret_cast<std::vector<SaInt32T*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      }
      break;
    case SA_IMM_ATTR_SAUINT32T: {
      std::vector<SaUint32T*> *value =
          reinterpret_cast<std::vector<SaUint32T*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SAINT64T: {
      std::vector<SaInt64T*> *value =
          reinterpret_cast<std::vector<SaInt64T*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SAUINT64T: {
      std::vector<SaUint64T*> *value =
          reinterpret_cast<std::vector<SaUint64T*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SATIMET: {
      std::vector<SaTimeT*> *value =
          reinterpret_cast<std::vector<SaTimeT*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SANAMET: {
      std::vector<SaNameT*> *value =
          reinterpret_cast<std::vector<SaNameT*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SAFLOATT: {
      std::vector<SaFloatT*> *value =
          reinterpret_cast<std::vector<SaFloatT*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SADOUBLET: {
      std::vector<SaDoubleT*> *value =
          reinterpret_cast<std::vector<SaDoubleT*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    case SA_IMM_ATTR_SASTRINGT: {
      std::vector<SaStringT*> *value =
          reinterpret_cast<std::vector<SaStringT*>*>(&attribute->value);
      ccb_object->SetAttributeValue(attribute->name, *value);
      break;
    }
    default: {
      std::cerr << "Unknown type: " << attribute->type << std::endl;
      break;
    }
  }
}

void ImmCppCfg::SetModifyAttribute(
    immom::ImmOmCcbObjectModify *ccb_obj, AttributeInfoT *attribute) {
  switch (attribute->type) {
    case SA_IMM_ATTR_SAINT32T: {
      std::vector<SaInt32T*> *value =
          reinterpret_cast<std::vector<SaInt32T*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      }
      break;
    case SA_IMM_ATTR_SAUINT32T: {
      std::vector<SaUint32T*> *value =
          reinterpret_cast<std::vector<SaUint32T*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SAINT64T: {
      std::vector<SaInt64T*> *value =
          reinterpret_cast<std::vector<SaInt64T*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SAUINT64T: {
      std::vector<SaUint64T*> *value =
          reinterpret_cast<std::vector<SaUint64T*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SATIMET: {
      std::vector<SaTimeT*> *value =
          reinterpret_cast<std::vector<SaTimeT*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SANAMET: {
      std::vector<SaNameT*> *value =
          reinterpret_cast<std::vector<SaNameT*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SAFLOATT: {
      std::vector<SaFloatT*> *value =
          reinterpret_cast<std::vector<SaFloatT*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SADOUBLET: {
      std::vector<SaDoubleT*> *value =
          reinterpret_cast<std::vector<SaDoubleT*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    case SA_IMM_ATTR_SASTRINGT: {
      std::vector<SaStringT*> *value =
          reinterpret_cast<std::vector<SaStringT*>*>(&attribute->value);
      SetModifyAttributeValue(
          ccb_obj, attribute->name, *value, attribute->modify_type);
      break;
    }
    default: {
      std::cerr << "Unknown type: " << attribute->type << std::endl;
      break;
    }
  }
}

template<typename T>
void ImmCppCfg::SetModifyAttributeValue(
    immom::ImmOmCcbObjectModify *ccb_object,
    const std::string &attribute_name,
    const std::vector<T*> &attribute_value,
    const CfgModifyAttributeT &modify_type) const {
  assert(ccb_object != nullptr);
  switch (modify_type) {
    case KModifiedAddedAttribute:
        ccb_object->AddAttributeValue(attribute_name, attribute_value);
      break;
    case KModifiedReplacedAttribute:
      ccb_object->ReplaceAttributeValue(attribute_name, attribute_value);
      break;
    case KModifiedDeletedAttribute:
      ccb_object->DeleteAttributeValue(attribute_name, attribute_value);
      break;
    default:
      std::cerr << "Unknown type of modification: " << modify_type << std::endl;
      break;
  }
}

void ImmCppCfg::FreeAttributeValue(void *value, SaImmValueTypeT type) {
  switch (type) {
      case SA_IMM_ATTR_SAINT32T:
        delete reinterpret_cast<SaInt32T*>(value);
        break;

      case SA_IMM_ATTR_SAUINT32T:
        delete reinterpret_cast<SaUint32T*>(value);
        break;

      case SA_IMM_ATTR_SAINT64T:
        delete reinterpret_cast<SaInt64T*>(value);
        break;

      case SA_IMM_ATTR_SAUINT64T:
        delete reinterpret_cast<SaUint64T*>(value);
        break;

      case SA_IMM_ATTR_SANAMET:
        osaf_extended_name_free(reinterpret_cast<SaNameT*>(value));
        delete reinterpret_cast<SaNameT*>(value);
        break;

      case SA_IMM_ATTR_SAFLOATT:
        delete reinterpret_cast<SaFloatT*>(value);
        break;

      case SA_IMM_ATTR_SADOUBLET:
        delete reinterpret_cast<SaDoubleT*>(value);
        break;

      case SA_IMM_ATTR_SASTRINGT:
        free(*reinterpret_cast<SaStringT*>(value));
        delete reinterpret_cast<SaStringT*>(value);
        break;

      case SA_IMM_ATTR_SAANYT:
        delete[] (reinterpret_cast<SaAnyT*>(value))->bufferAddr;
        delete reinterpret_cast<SaAnyT*>(value);
        break;
      default:
        std::cerr << "Unknown type: " << type << std::endl;
        break;
    }
}

void ImmCppCfg::FreeAttribute(AttributeInfoT *attribute) {
  for (auto val : attribute->value)
    if (val) FreeAttributeValue(val, attribute->type);

  delete attribute;
  attribute = nullptr;
}

SaImmClassNameT ImmCppCfg::GetClassName(const std::string &object_name) {
  SaImmClassNameT class_name = nullptr;
  std::vector<SaImmAttrValuesT_2*> attributes;

  immom::ImmOmAccessorHandle accessorhandle{om_handle_->GetHandle()};
  if (accessorhandle.InitializeHandle() == false) {
    std::cerr << "OM accessor handle: InitializeHandle() failed: " <<
        saf_error(accessorhandle.ais_error()) << std::endl;
    return nullptr;
  }

  immom::ImmOmAccessorGet accessorget{accessorhandle.GetHandle(), object_name};
  accessorget.SetAttributeNames("SaImmAttrClassName");
  if (accessorget.FetchAttributeValue() == true) {
    attributes = accessorget.GetAllAttributeProperties();
    class_name =
        strdup(*reinterpret_cast<char**>(attributes[0]->attrValues[0]));
  } else if (accessorget.ais_error() == SA_AIS_ERR_NOT_EXIST) {
    // TODO(xcantru): implement saImmOmCcbObjectRead
  } else {
    std::cerr << "OM accessor get: GetAccessor() failed: " <<
        saf_error(accessorget.ais_error()) << std::endl;
    return nullptr;
  }

  return class_name;
}

void *ImmCppCfg::AllocateAttributeValue(
    const SaImmValueTypeT &attrValueType, const std::string &value_str) {
  void *attribute_value = nullptr;
  char *endptr;
  const char *tmp_value_str = value_str.c_str();
  size_t len;

  // sizeof(long) varies between 32 and 64 bit machines. Therefore on a 64
  // bit machine, a check is needed to ensure that the value returned from
  // strtol() or strtoul() is not greater than what fits into 32 bits.
  switch (attrValueType) {
  case SA_IMM_ATTR_SAINT32T: {
    errno = 0;
    int64_t value = strtol(tmp_value_str, &endptr, 0);
    SaInt32T attr_value = value;
    if ((errno != 0) || (endptr == tmp_value_str) || (*endptr != '\0')) {
      std::cerr << "int32 conversion failed" << std::endl;
      return nullptr;
    }
    if (value != attr_value) {
      std::cerr <<"int32 conversion failed, value too large " << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaInt32T());
    *reinterpret_cast<SaInt32T*>(attribute_value) = value;
    break;
  }
  case SA_IMM_ATTR_SAUINT32T: {
    errno = 0;
    uint64_t value = strtoul(tmp_value_str, &endptr, 0);
    SaUint32T attr_value = value;
    if ((errno != 0) || (endptr == tmp_value_str) || (*endptr != '\0')) {
      std::cerr << "uint32 conversion failed" << std::endl;
      return nullptr;
    }
    if (value != attr_value) {
      std::cerr << "uint32 conversion failed, value too large" << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaUint32T());
    *reinterpret_cast<SaUint32T*>(attribute_value) = value;
    break;
  }
  case SA_IMM_ATTR_SAINT64T:
  // fall-through, same basic data type
  case SA_IMM_ATTR_SATIMET: {
    errno = 0;
    int64_t value = strtoll(tmp_value_str, &endptr, 0);
    if ((errno != 0) || (endptr == tmp_value_str) || (*endptr != '\0')) {
      std::cerr << "int64 conversion failed" << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaInt64T());
    *reinterpret_cast<SaInt64T*>(attribute_value) = value;
    break;
  }
  case SA_IMM_ATTR_SAUINT64T: {
    errno = 0;
    uint64_t value = strtoull(tmp_value_str, &endptr, 0);
    if ((errno != 0) || (endptr == tmp_value_str) || (*endptr != '\0')) {
      std::cerr << "uint64 conversion failed" << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaUint64T());
    *reinterpret_cast<SaUint64T*>(attribute_value) = value;
    break;
  }
  case SA_IMM_ATTR_SAFLOATT: {
    errno = 0;
    float myfloat = strtof(tmp_value_str, &endptr);
    if (((myfloat == 0) && (endptr == tmp_value_str)) || (errno == ERANGE) ||
        (*endptr != '\0')) {
      std::cerr << "float conversion failed" << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaFloatT());
    *reinterpret_cast<SaFloatT*>(attribute_value) = myfloat;
    break;
  }
  case SA_IMM_ATTR_SADOUBLET: {
    errno = 0;
    double mydouble = strtod(tmp_value_str, &endptr);
    if (((mydouble == 0) && (endptr == tmp_value_str)) || (errno == ERANGE) ||
        (*endptr != '\0')) {
      std::cerr << "double conversion failed" << std::endl;
      return nullptr;
    }
    attribute_value = reinterpret_cast<void*>(new SaDoubleT());
    *reinterpret_cast<SaDoubleT*>(attribute_value) = mydouble;
    break;
  }
  case SA_IMM_ATTR_SANAMET: {
    SaNameT *mynamet;
    len = strlen(tmp_value_str);
    attribute_value = reinterpret_cast<void*>(new SaNameT());
    mynamet = reinterpret_cast<SaNameT*>(attribute_value);
    saAisNameLend(len < SA_MAX_UNEXTENDED_NAME_LENGTH ?
        tmp_value_str : strdup(tmp_value_str),  mynamet);
    break;
  }
  case SA_IMM_ATTR_SASTRINGT: {
    attribute_value = reinterpret_cast<void*>(new SaStringT());
    *reinterpret_cast<SaStringT*>(attribute_value) = strdup(tmp_value_str);
    break;
  }
  case SA_IMM_ATTR_SAANYT: {
    char *endMark;
    bool even = true;
    char byte[5];
    unsigned int i;

    len = strlen(tmp_value_str);
    if (len % 2) {
      len = len / 2 + 1;
      even = false;
    } else {
      len = len / 2;
    }
    attribute_value = reinterpret_cast<void*>(new SaAnyT());
    (reinterpret_cast<SaAnyT*>(attribute_value))->bufferAddr =
        reinterpret_cast<SaUint8T*>(new SaUint8T*[len]());
    (reinterpret_cast<SaAnyT*>(attribute_value))->bufferSize = len;

    byte[0] = '0';
    byte[1] = 'x';
    byte[4] = '\0';

    endMark = byte + 4;

    for (i = 0; i < len; i++) {
      byte[2] = tmp_value_str[2 * i];
      if (even || (i + 1 < len)) {
        byte[3] = tmp_value_str[2 * i + 1];
      } else {
        byte[3] = '0';
      }
      (reinterpret_cast<SaAnyT*>(attribute_value))->bufferAddr[i] =
          static_cast<SaUint8T>(strtod(byte, &endMark));
    }
  }
  default:
    break;
  }

  return attribute_value;
}

AttributeInfoT* ImmCppCfg::FetchNewAttributeInfo(
    const immom::ImmOmClassDescriptionGet &class_desctiption,
    const std::string &attribute_in_string,
    bool is_rdn) {
  std::size_t found = attribute_in_string.find_first_of('=');
  if (found == std::string::npos) {
    fprintf(stderr, "The Attribute '%s' does not contain a equal sign ('=')\n",
            attribute_in_string.c_str());
    return nullptr;
  }
  std::string attribute_name = attribute_in_string.substr(0, found);
  std::string attribute_value = attribute_in_string.substr(found + 1);

  if (is_rdn) attribute_value = attribute_in_string;

  VERBOSE_INFO("FetchNewAttributeInfo attrName: '%s' attrValue:'%s'\n",
               attribute_name.c_str(), attribute_value.c_str());

  const SaImmValueTypeT* value_type =
      class_desctiption.GetAttributeValueType(attribute_name);
  if (value_type == nullptr) {
    fprintf(stderr, "Attribute '%s' does not exist in class\n",
            attribute_name.c_str());
    return nullptr;
  }

  void* value_attr = AllocateAttributeValue(*value_type, attribute_value);
  if (value_attr == nullptr) {
    fprintf(stderr, "Error - Cannot allocate memory for attribute value\n");
    return nullptr;
  }

  AttributeInfoT *attribute = new AttributeInfoT();
  attribute->name = attribute_name;
  attribute->type = *value_type;
  attribute->value.push_back(value_attr);

  return attribute;
}

// Fetch modified attribute name and its value from string in command-line
AttributeInfoT* ImmCppCfg::FetchModifiedAttributeInfo(
    const immom::ImmOmClassDescriptionGet &class_desctiption,
    const std::string &attribute_in_string) {
  std::string attribute_name;
  std::string attribute_value;
  CfgModifyAttributeT modify_type;
  const SaImmValueTypeT *value_type;

  std::size_t found = attribute_in_string.find_first_of('=');
  if (found == std::string::npos) {
    fprintf(stderr, "The Attribute '%s' does not contain a equal sign ('=')\n",
            attribute_in_string.c_str());
    return nullptr;
  }

  if (attribute_in_string.at(found-1) == '+') {
    modify_type = KModifiedAddedAttribute;
    attribute_name = attribute_in_string.substr(0, found - 1);
  } else if (attribute_in_string.at(found-1) == '-') {
    modify_type = KModifiedDeletedAttribute;
    attribute_name = attribute_in_string.substr(0, found - 1);
  } else {
    modify_type = KModifiedReplacedAttribute;
    attribute_name = attribute_in_string.substr(0, found);
  }

  attribute_value = attribute_in_string.substr(found + 1);

  VERBOSE_INFO("FetchModifiedAttributeInfo attrName: '%s' attrValue:'%s'\n",
               attribute_name.c_str(), attribute_value.c_str());

  value_type = class_desctiption.GetAttributeValueType(attribute_name);
  if (value_type == nullptr) {
    fprintf(stderr, "Attribute '%s' does not exist in class\n",
            attribute_name.c_str());
    return nullptr;
  }

  AttributeInfoT *attribute = new AttributeInfoT();
  attribute->name = attribute_name;
  attribute->type = *value_type;
  attribute->modify_type = modify_type;

  if (attribute_value.empty() == false) {
    void* value_attr = AllocateAttributeValue(*value_type, attribute_value);
    if (value_attr == nullptr) {
      fprintf(stderr, "Error - Cannot allocate memory for attribute value\n");
      return nullptr;
    }
    attribute->value.push_back(value_attr);
  }

  return attribute;
}

bool ImmCppCfg::GetNewAttributeInfo(
    const immom::ImmOmClassDescriptionGet& class_description,
    const std::vector<std::string> &attributes_str) {
  AttributeInfoT *attribute = nullptr;
  SaImmAttrFlagsT attribute_flag = 0;

  // Parse all attributes in string and its values
  for (auto a : attributes_str) {
    attribute = FetchNewAttributeInfo(class_description, a.c_str(), false);
    if (attribute == nullptr) return false;

    attribute_flag = *class_description.GetAttributeFlags(attribute->name);
    // Check if multiple values
    bool is_multi_value = false;
    for (auto attr : attributes_list_) {
      if ((attribute->name.compare(attr->name) == 0) &&
          (attribute_flag & SA_IMM_ATTR_MULTI_VALUE)) {
        is_multi_value = true;
        void *multi_value = attribute->value[0];
        attr->value.push_back(multi_value);

        attribute->value[0] = nullptr;
        FreeAttribute(attribute);
        break;
      }
    }

    if (is_multi_value == false)
      attributes_list_.push_back(attribute);
  }

  return true;
}

bool ImmCppCfg::GetNewRdnAndParent(
    const immom::ImmOmClassDescriptionGet& class_description,
    const std::vector<std::string> &objects_str) {
  // Parse all objects string from input to get parent and rdn
  for (auto object : objects_str) {
    std::size_t found = object.find_first_of(',');

    std::string rdn_in_string = object.substr(0, found);
    AttributeInfoT *rdn =
        FetchNewAttributeInfo(class_description, rdn_in_string, true);
    if (rdn == nullptr) return false;

    // Store rdn and parent to list
    ObjectInfoT* object_info = new ObjectInfoT();
    object_info->rdn = rdn;
    if (found != std::string::npos)
      object_info->parent = object.substr(found + 1);

    objects_info_list_.push_back(object_info);
  }

  return true;
}

bool ImmCppCfg::GetModifiedAttributeInfo(
    const immom::ImmOmClassDescriptionGet& class_description,
    const std::vector<std::string> &attributes_str) {
  AttributeInfoT *attribute = nullptr;
  SaImmAttrFlagsT attribute_flag = 0;

  // Parse all attributes and its values
  for (auto a : attributes_str) {
    VERBOSE_INFO("ModifyObject: '%s'\n", a.c_str());
    attribute = FetchModifiedAttributeInfo(class_description, a.c_str());
    if (attribute == nullptr) {
      std::cerr << "Error - Creating none-exist attribute" <<
          a.c_str() << std::endl;
      return false;
    }

    attribute_flag = *class_description.GetAttributeFlags(attribute->name);
    // Check if multiple value
    bool is_multi_value = false;
    for (auto attr : attributes_list_) {
      if ((attribute->name.compare(attr->name) == 0) &&
          (attribute_flag & SA_IMM_ATTR_MULTI_VALUE)) {
        if (attribute->modify_type != attr->modify_type) {
          std::cerr << "Error - Only one Modify operation type is supported for"
              " attribute" << std::endl;
          FreeAttribute(attribute);
          return false;
        }

        if (attribute->value.empty()) {
          std::cerr << "Error - Empty value is used for adding Multiple value"
              " attribute" << std::endl;
          FreeAttribute(attribute);
          return false;
        }

        is_multi_value = true;
        void *multi_value = attribute->value[0];
        attr->value.push_back(multi_value);

        attribute->value[0] = nullptr;
        FreeAttribute(attribute);
        break;
      }
    }

    if (is_multi_value == false)
      attributes_list_.push_back(attribute);
  }

  return true;
}

bool ImmCppCfg::CreateObject(
    const std::vector<std::string> &objects_str,
    const std::string &class_name,
    const std::vector<std::string> &attributes_str) {
  SaAisErrorT ais_code = SA_AIS_OK;
  immom::ImmOmAdminOwnerSet *admin_owner_set = nullptr;

  immom::ImmOmClassDescriptionGet class_description(om_handle_->GetHandle(),
                                                    class_name);
  if (class_description.GetClassDescription() == false) {
    std::cerr << "GetClassDescription failed: " <<
        saf_error(class_description.ais_error()) << std::endl;
    return false;
  }

  // Step1: Get attributes's info, rdn and parent
  if (GetNewAttributeInfo(class_description, attributes_str) == false) {
    return false;
  }
  if (GetNewRdnAndParent(class_description, objects_str) == false) {
    return false;
  }

  // Step2: Initialize Immom Ccb handle
  immom::ImmOmCcbHandle ccbhandle(admin_owner_handle_->GetHandle(),
                                  ccb_safe ? KDefCcbFlags : 0x0);
  if (ccbhandle.InitializeHandle() == false) {
    std::cerr << "omccbhandle initialize failed: " <<
        saf_error(ccbhandle.ais_error()) << std::endl;
    return false;
  }

  for (auto object_info : objects_info_list_) {
    // Step4: Ccb object create
    immom::ImmOmCcbObjectCreate ccb_object_create(
        ccbhandle.GetHandle(), class_name);

    AttributeInfoT* rdn = object_info->rdn;
    std::string parent = object_info->parent;
    if (parent.empty() == false) {
      // Step3: Admin owner set for parent class of object
      admin_owner_set =
          new immom::ImmOmAdminOwnerSet(admin_owner_handle_->GetHandle(),
                                        parent);
      if (admin_owner_set->SetAdminOwner(SA_IMM_ONE) == false) {
        ais_code = admin_owner_set->ais_error();
        if (ais_code == SA_AIS_ERR_NOT_EXIST)
          std::cerr << "Error - Doesn't exist parent: "<< parent << std::endl;
        else
          std::cerr << "SetAdminOwner failed: " <<
                       saf_error(ais_code) << std::endl;

        delete admin_owner_set;
        return false;
      }

      ccb_object_create.SetParentName(parent);
    }

    SetNewAttribute(&ccb_object_create, rdn);
    for (auto a : attributes_list_) SetNewAttribute(&ccb_object_create, a);

    if (ccb_object_create.AddObjectCreateToCcb() == false) {
      ais_code = ccb_object_create.ais_error();
      std::cerr << "Error - AddObjectCreateToCcb FAILED with " <<
          saf_error(ais_code) << std::endl;
      // TODO(xcantru): implement saImmOmCcbGetErrorStrings

      delete admin_owner_set;
      return false;
    }

    delete admin_owner_set;
    admin_owner_set = nullptr;
  }

  //  Step5: Apply Ccb create
  if (ccbhandle.ApplyCcb() == false) {
    std::cerr << "ApplyCcb create failed: "
              << saf_error(ccbhandle.ais_error()) << std::endl;
    // TODO(xcantru): implement saImmOmCcbGetErrorStrings
    return false;
  }

  return true;
}

bool ImmCppCfg::ModifyObject(
    const std::vector<std::string> &object_names,
    const std::vector<std::string> &attributes_str) {
  SaAisErrorT ais_code = SA_AIS_OK;

  // // Step1: Get attributes's info from input comman-line string
  SaImmClassNameT class_name = GetClassName(object_names[0]);
  if (class_name == nullptr) {
    std::cerr << "Error - Does not exist object DN:" <<
        object_names[0] << std::endl;
    return false;
  }
  immom::ImmOmClassDescriptionGet class_description(om_handle_->GetHandle(),
                                                    class_name);
  if (class_description.GetClassDescription() == false) {
    std::cerr << "GetClassDescription failed: " <<
        saf_error(class_description.ais_error()) << std::endl;
    return false;
  }

  // Get all attributes's info from input attributes string
  if (GetModifiedAttributeInfo(class_description, attributes_str) == false) {
    return false;
  }

  // Step2: Admin owner set for object names
  immom::ImmOmAdminOwnerSet adminset(admin_owner_handle_->GetHandle(),
                                     object_names);
  if (adminset.SetAdminOwner(SA_IMM_ONE) == false) {
    ais_code = adminset.ais_error();
    if (ais_code == SA_AIS_ERR_NOT_EXIST)
      std::cerr << "Error - Object does not exist " << std::endl;
    else
      std::cerr << "SetAdminOwner failed: " <<
            saf_error(ais_code) << std::endl;
    return false;
  }

  // Step3: Initialize Immom Ccb handle
  immom::ImmOmCcbHandle ccbhandle(admin_owner_handle_->GetHandle(),
                                  ccb_safe ? KDefCcbFlags : 0x0);
  if (ccbhandle.InitializeHandle() == false) {
    std::cerr << "omccbhandle initialize failed: " <<
        saf_error(ccbhandle.ais_error()) << std::endl;
    return false;
  }

  // Step4: Modify objects
  for (auto name : object_names) {
    VERBOSE_INFO("ModifyObject: object name: '%s'\n", name.c_str());
    immom::ImmOmCcbObjectModify ccb_object_modify(ccbhandle.GetHandle(), name);

    for (auto a : attributes_list_)
      SetModifyAttribute(&ccb_object_modify, a);

    if (ccb_object_modify.AddObjectModifyToCcb() == false) {
      std::cerr << "Modify Object failed: " <<
          saf_error(ccb_object_modify.ais_error())<< std::endl;
      // TODO(xcantru): Implement for saImmOmCcbGetErrorStrings
      return false;
    }
  }

  //  Step5: Apply Ccb
  if (ccbhandle.ApplyCcb() == false) {
    std::cerr << "ApplyCcb modify failed: "
              << saf_error(ccbhandle.ais_error()) << std::endl;
    // TODO(xcantru): Implement for saImmOmCcbGetErrorStrings
    return false;
  }

  return true;
}

bool ImmCppCfg::DeleteObject(
    const std::vector<std::string> &object_names) {

  SaAisErrorT ais_code;
  // Step1: Admin owner set for object names
  immom::ImmOmAdminOwnerSet adminset(admin_owner_handle_->GetHandle(),
                                     object_names);
  if (adminset.SetAdminOwner(SA_IMM_SUBTREE) == false) {
    ais_code = adminset.ais_error();
    if (ais_code == SA_AIS_ERR_NOT_EXIST)
      std::cerr << "Error - Object does not exist " << std::endl;
    else
      std::cerr << "SetAdminOwner failed: " <<
            saf_error(ais_code) << std::endl;
    return false;
  }

  // Step2: Initialize Immom Ccb handle
  immom::ImmOmCcbHandle ccbhandle(admin_owner_handle_->GetHandle(),
                                  ccb_safe ? KDefCcbFlags : 0x0);
  if (ccbhandle.InitializeHandle() == false) {
    std::cerr << "omccbhandle initialize failed: " <<
        saf_error(ccbhandle.ais_error()) << std::endl;
    return false;
  }

  // Step3: Ccb delete object
  immom::ImmOmCcbObjectDelete ccbdelete(ccbhandle.GetHandle());
  for (auto object_name : object_names) {
    if (ccbdelete.AddObjectDeleteToCcb(object_name) == false) {
      std::cerr << "DeleteObject failed: "
                << saf_error(ccbdelete.ais_error()) << std::endl;
      // TODO(xcantru): Implement for saImmOmCcbGetErrorStrings
      return false;
    }
  }

  //  Step4: Apply Ccb
  if (ccbhandle.ApplyCcb() == false) {
    std::cerr << "ApplyCcb delete failed: "
              << saf_error(ccbhandle.ais_error()) << std::endl;
    // TODO(xcantru): Implement for saImmOmCcbGetErrorStrings
    return false;
  }

  return true;
}

bool ImmCppCfg::DeleteClass(
    const std::vector<std::string> &class_names) {
  SaAisErrorT ais_code;

  immom::ImmOmClassDelete deleteclassobj(om_handle_->GetHandle());
  for (const auto class_name : class_names) {
    if (deleteclassobj.DeleteClass(class_name) == false) {
      ais_code = deleteclassobj.ais_error();
      if (ais_code == SA_AIS_ERR_NOT_EXIST)
        std::cerr << "Error - Class does not exist"
                  << class_name.c_str() << std::endl;
      else
        std::cerr << "Error - Delete class failed: "
                  << saf_error(ais_code) << std::endl;
      return false;
    }
  }

  return true;
}

bool ImmCppCfg::ClearAdminOwner(
    const std::vector<std::string> &object_names) {
  immom::ImmOmAdminOwnerClear adminownerclearobj(om_handle_->GetHandle(),
                                                 object_names);
  if (adminownerclearobj.ClearAdminOwner() == false) {
    std::cerr << "Error - Admin Owner clear failed: "
              << saf_error(adminownerclearobj.ais_error()) << std::endl;
    return false;
  }

  return true;
}

bool ImmCppCfg::InitHandle(
    bool use_admin_owner, std::string admin_owner_name) {
  // Initialize Immom handle
  om_handle_ = new immom::ImmOmHandle(imm_version);
  assert(om_handle_ != nullptr);
  if (om_handle_->InitializeHandle() == false) {
    std::cerr << "OM handle: InitializeHandle() failed: "
              << saf_error(om_handle_->ais_error()) << std::endl;
    return false;
  }

  if (use_admin_owner) {
    // Initialize Immom Admin Owner handle
    admin_owner_handle_ =
        new immom::ImmOmAdminOwnerHandle(om_handle_->GetHandle(),
                                         admin_owner_name);
    assert(admin_owner_handle_ != nullptr);
    if (admin_owner_handle_->InitializeHandle() == false) {
      std::cerr << "OM admin owner handle: InitializeHandle() failed: "
                << saf_error(admin_owner_handle_->ais_error()) << std::endl;
      return false;
    }
  }

  return true;
}

int main(int argc, char *argv[]) {
  bool ret = false;
  CfgOperationT op = KInvalidOperation;
  bool use_admin_owner = true;
  char* admin_owner_name = nullptr;
  uint64_t timeout = 60;
  std::vector<std::string> attributes{};
  std::string class_name{};
  std::vector<std::string> class_names{};
  std::vector<std::string> object_names{};

  struct option long_opts[] = {
      {"attribute", required_argument, NULL, 'a'},
      {"create-object", required_argument, NULL, 'c'},
      {"file", required_argument, NULL, 'f'},
      {"ignore-duplicates", no_argument, NULL, 0},
      // Note: should be 'no_arg'! treated as "Remaining args"  below
      {"delete-class", no_argument, NULL, 0},
      {"delete-object", no_argument, NULL, 'd'},
      {"help", no_argument, NULL, 'h'},
      {"modify-object", no_argument, NULL, 'm'},
      {"timeout", required_argument, NULL, 't'},
      {"verbose", no_argument, NULL, 'v'},
      {"unsafe", no_argument, NULL, 'u'},
      {"validate", required_argument, NULL, 'L'},
      {"class-name", required_argument, NULL, 0},
      {"enable-attr-notify", no_argument, NULL, 0},
      {"disable-attr-notify", no_argument, NULL, 0},
      {"admin-owner", required_argument, NULL, 'o'},
      {"admin-owner-clear", no_argument, NULL, 0},
      {"ccb-apply", no_argument, NULL, 0},
      {"ccb-abort", no_argument, NULL, 0},
      {"ccb-validate", no_argument, NULL, 0},
      {"xsd", required_argument, NULL, 'X'},
      {"strict", no_argument, NULL, 0},
      {0, 0, 0, 0}};

  // Support for long DN
  setenv("SA_ENABLE_EXTENDED_NAMES", "1", 1);
  osaf_extended_name_init();

  while (1) {
    int option_index = 0;
    int c = getopt_long(argc, argv, "a:c:f:t:dhmvuL:o:X:", long_opts,
                        &option_index);

    // Have all command-line options have been parsed
    if (c == -1)
      break;

    switch (c) {
      case 0:
        VERBOSE_INFO("Long option[%d]: %s\n", option_index,
               long_opts[option_index].name);
        if (strcmp("delete-class", long_opts[option_index].name) == 0) {
          op = VerifySetOption(op, KDeleteClass);
        } else if (!strcmp("admin-owner-clear", long_opts[option_index].name)) {
          op = VerifySetOption(op, KAdminOnwerClear);
          use_admin_owner = false;
        } else if (strcmp("class-name", long_opts[option_index].name) == 0) {
          op = VerifySetOption(op, KChangeClass);
          class_name = optarg;
        }
        break;
      case 'a':
        attributes.push_back(optarg);
        break;
      case 'c':
        class_name = optarg;
        op = VerifySetOption(op, KCreateObject);
        break;
      case 'd':
        op = VerifySetOption(op, KDeleteObject);
        break;
      case 'h':
        usage(basename(argv[0]));
        return 0;
      case 'f':
//        op = VerifySetOption(op, LOAD_IMMFILE);
//        xmlFilename = optarg;
        break;
      case 't':
        timeout = strtol(optarg, nullptr, 10);
        break;
      case 'v':
        verbose = true;
        break;
      case 'u':  // Unsafe mode
        ccb_safe = false;
        break;
      case 'm':
        op = VerifySetOption(op, KModifyObject);
        break;
      case 'L':
//        op = VerifySetOption(op, VALIDATE_IMMFILE);
//        xmlFilename = optarg;
        break;
      case 'o':
        if (admin_owner_name) {
          fprintf(stderr, "Administrative owner name can be set only once\n");
          exit(EXIT_FAILURE);
        }
        admin_owner_name = new char[strlen(optarg) + 1]();
        strncpy(admin_owner_name, optarg, strlen(optarg) + 1);
        break;
      case 'X':
        break;
    default:
      fprintf(stderr, "Try '%s --help' for more information\n", argv[0]);
      exit(EXIT_FAILURE);
      break;
    }
  }

  if (!admin_owner_name)
    admin_owner_name = CreateAdminOwnerName(basename(argv[0]));

  signal(SIGALRM, sigalarmh);
  alarm(timeout);

  if (op == KInvalidOperation) {
    VERBOSE_INFO("No option specified - defaults to MODIFY\n");
    // Modify is default
    op = KModifyObject;
  }

  if (verbose) {
    VERBOSE_INFO("Operation:%d argc:%d optind:%d\n", op, argc, optind);

    if (optind < argc) {
      VERBOSE_INFO("non-option ARGV-elements: ");
      for (int i = optind; i < argc; i++) {
        VERBOSE_INFO("%s ", argv[i]);
      }
      VERBOSE_INFO("\n");
    }
  }

  // Specify at least one object or class
  if ((argc - optind) < 1) {
    fprintf(stderr, "Error - Specify at least one object or class\n");
    delete[] admin_owner_name;
    exit(EXIT_FAILURE);
  }

  // Change default global settings
  const ImmBase::RetryControl ctrl{base::kOneHundredMilliseconds,
        static_cast<uint64_t>(timeout*1000)};
  ImmBase::ChangeDefaultRetryControl(ctrl);
  ImmBase::ChangeDefaultImmVersion(imm_version);

  if (op == KDeleteClass) {
    while (optind < argc)
      class_names.push_back(argv[optind++]);
  } else if (op == KChangeClass) {
    // TODO(xcantru): Wait for saImmOmAdminOperationInvoke_2
  } else {
    // Get all object names
    while (optind < argc)
      object_names.push_back(argv[optind++]);
  }

  // Declare object's of ImmCppCfg class
  ImmCppCfg immcppcfg_obj;

  // Initialize om handle and admin owner handle
  if (immcppcfg_obj.InitHandle(use_admin_owner, admin_owner_name) == false) {
    delete[] admin_owner_name;
    exit(EXIT_FAILURE);
  }

  switch (op) {
  case KCreateObject:
    ret = immcppcfg_obj.CreateObject(
              object_names, class_name, attributes);
    break;
  case KModifyObject:
    ret = immcppcfg_obj.ModifyObject(object_names, attributes);
    break;
  case KDeleteObject:
    ret = immcppcfg_obj.DeleteObject(object_names);
    break;
  case KDeleteClass:
    ret = immcppcfg_obj.DeleteClass(class_names);
    break;
  case KAdminOnwerClear:
    ret = immcppcfg_obj.ClearAdminOwner(object_names);
    break;
  default:
    std::cerr << "Error - No operation specified" << std::endl;
    break;
  }

  delete[] admin_owner_name;

  if (ret == false)
    exit(EXIT_FAILURE);

  return 0;
}
