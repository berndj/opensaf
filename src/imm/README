#
#      -*- OpenSAF  -*-
#
# (C) Copyright 2008 The OpenSAF Foundation
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
# under the GNU Lesser General Public License Version 2.1, February 1999.
# The complete license can be accessed from the following location:
# http://opensource.org/licenses/lgpl-license.php
# See the Copying file included with the OpenSAF distribution for full
# licensing terms.
#
# Author(s): Ericsson AB
#

GENERAL
=======
This directory (osaf/services/saf/immsv) contains an implementation of the
SAF IMM service version A.02.01.

Application programmers intending to interface with immsv should primarily read
the document "OpenSAF IMM Service Release 4 Programmer's Reference" and of
course the IMM standard (SAI-AIS-IMM-A.02.01).

This document provides an overview of the design and internals of the immsv.
It is intended for maintainers or trouble-shooters of the immsv in OpenSAF.
Familiarity with the IMM standard is obviously also needed for understanding
this document.

The IMM service follows the three tier OpenSAF "Service Director" framework
(see OpenSAF Overview User's Guide).
As such, the process structure consists of:

        * The IMM Director process type (IMMD).
        * The IMM Node Director process type (IMMND).
        * The application procesesses linked with the IMM Agent library (IMMA).

IMMD
====
The IMMD is implemented as a server process executing on the controllers using
a 2N redundancy model. The IMMD on the active controller can be seen as the
"central master" of the IMM service. The standby IMMD is kept up-to-date by the
active IMMD using the message based checkpointing service. If the active
controller goes down, the standby controller becomes active by order from the
AMF. A crash of any director process, such as the IMMD, will escalate to a
restart of the active controller, which of course implies a fail-over of the
directors for all services.

The active IMMD tracks the cluster membership (using MDS) and controls
which nodes/IMMNDs currently can provide access to the IMM service.
Note: the current implementation of IMM does not use the SAF CLM service.
That service is only at the node level. The cluster that is tracked by the IMMD
will loose and gain membership not only when nodes leave and join, but also when
IMMND processes crash and restart. The crash of an IMMND process does *not*
imply the restart of the node where it executes.

The set of IMMNDs known by the IMMD is the basis for the two main functions of
the IMMD:

        * FEVS, a reliable multicast between IMMNDs.
        * Election of IMMND coordinator.

To understand the current implementation of the IMM service, it helps to know
that it was first developed in a different context. That context used Extended
Virtual Synchrony (EVS) as the basic cluster communication protocol.
It had only one server process type implementing the IMM service and it executed
symmetrically, one server process on each node. That implementation has now been
ported to the OpenSAF middle-ware. The single symmetrically distributed process
now corresponds to the IMMND process type. The IMMD provides a replacement for
EVS that we call FEVS.

FEVS (Fake EVS) is so named because it roughly emulates the semantics (but not
the API) of EVS. That is, FEVS tries to provide a reliable multicast over a set
of members plus control over changes of membership. By "reliable" we mean that
any FEVS message arriving at a member, must arrive at all current members and
in the same order. Thus it provides non-loss and uniform ordering of messages.
In addition, when a member joins or leaves, the other members see that join or
leave at the same point in the FEVS message sequence.

The other function of the IMMD, election of IMMND coordinator, concerns a minor
asymmetry between the IMMNDs. One of the current IMMND members has to take on
the role of IMMND coordinator. Exactly what this means is explained in the next
section. Here it suffices to say that it does not matter which one of the
current IMMND members takes on this role, only that one and only one of the
IMMNDs has this role at all times. The IMMD will always decide which IMMND is
the current coordinator.

The IMMD is quite lean, simple and small in its functionality. It is almost not
imm service specific at all. This increases the probability that it is robust
and stays so. This is good given the serious escalation caused by the failure
of any director process, in OpenSAF.


IMMND
=====
The IMMND is implemented as a server process executing on all nodes (both
controllers and payloads) according to the "No Redundancy" model. Each IMMND
handles all connections made by clients to the IMM service, at that node.
This off-loads the central IMMD server from handling any client related data.
In fact, an IMMD fail-over will not impact any clients, except the clients at
the active controller itself which has to restart.

The IMMND process is the "real" IMM server. It contains the IMM data model,
which holds the configuration and runtime objects that is the core of the
IMM service. It also has information about all implementers, admin-owners and
CCBs currently registered. In the current implementation, this repository is
symmetrically replicated over the IMMND at all processors. This will optimise
for read access, since all such accesses can be kept purely node-local.

Updates on the other hand, must be replicated to all IMMNDs. To ensure that all
IMMNDs are kept consistent and complete, the IMM service uses the FEVS protocol
provided by the IMMD. When a client issues a request that implies a mutation of
the IMM repository, the local IMMND that receives the request does not
immediately apply the request. Instead it FEVS forwards the request to the IMMD.
The IMMD in turn will add a sequence number to the message and then forward the
message to all IMMNDs (including the originating IMMND), using MDS broadcast.

Since all such messages pass through the single active IMMD process, a total
order is enforced. The sequence number added by the IMMD is only used as a
redundant check for completeness (non-loss). Any IMMND that receives an
out-of-sequence message will not apply that message. Instead it will either
restart and request a "sync"; or it may request a resend from the IMMD of the
missing message(s). [The resend variant is not yet fully implemented.]

The IMMND processes are in essence symmetrically equivalent. But there are a few
important exceptions. First, the details of connections are maintained only at
the local IMMND. Other IMMNDs will, for example, know which node an attached
implementer resides on, but not the exact connection for a remote implementer.
Any need to reach a remote implementer is solved by communicating with the
IMMND at that node. Second, at all times when the IMM service is operational,
one and only one of the IMMNDs is designated the IMMND-coordinator. The IMMND
that is currently the coordinator will take on the task of conducting a few
cluster global operations when needed:

        * Initial loading;
        * Sync of restarted IMMNDs;
        * Aborting CCBs waiting on apparently hung implementors.

A very good question here is: why not move the IMMND coordinator role to the
active IMMD? This is indeed possible to do, but there are at least a few
arguments against it.

First, these three tasks depend on knowledge of the current state of CCBs.
At the start of a sync, there is a period of grace where the IMMSv will not
accept new CCBs, but will allow already started CCBs to complete. A CCB can not
be aborted if it is in the critical phase of distributed commit. Loading also
has to be coordinated with sync, because the loading is often followed
immediately by a sync of any straggler nodes that missed the start of the
loading sequence. The dependency on CCB state could be solved by involving the
IMMD in the CCB life cycle. But since all IMMNDs are already involved in the CCB
handling and sync, there is no real simplification in also involving the IMMD.
The only way to really simplify would be to move the entire repository to the
IMMD, converting to the "Service Server" framework, or possibly keeping the
IMMNDs but only for client connection management. Indeed, we may end up there in
the future.

Second, there is a strong argument for keeping the IMMDs simple and by
implication robust. A crash of an IMMD causes a controller fail-over, but a
crash of an IMMND, even on the active controller, only causes a restart of the
IMMND.

Finally, another reason why the IMMND coordinator role does not reside with the
active IMMD is historical, that it was ported from an EVS based implementation.

The coordinator IMMND can theoretically be any IMMND in the system. In the
current implementation we have restricted it to reside on a controller node.
The only reason for this restriction is that the task of loading requires
access to the file system and we do not wish to assume that payloads have such
access. In the future we may enhance the reliability of the IMM service by
allowing any IMMND to become coordinator once the IMMNDs have loaded.

The current limitation, that the IMMND coordinator must reside on a controller,
has a downside.  If the IMMNDs at both controllers fail, the IMMD can not elect
any coordinator. Instead the IMMD has to order all IMMNDs to restart, which
currently causes a cluster restart.


IMMA
====

The client interface conforms to the OpenSAF agent library framework. The IMMA
library (libSaImmOm.so and libSaImmOi.so) only communicate with the node local
IMMND process. As explained previously, all read accesses made by the client
are kept node-local. In addition, the values for basic immsv handles:

        SaImmHandleT
        SaImmSearchHanldeT
        SaImmAccessorHandleT
        SaImmOiHandleT

are all set by the local IMMND without going remote to the IMMD or other IMMNDs.
The following handles are related to resource allocation, need global validity
and therefore are initialised over FEVS.

        SaImmAdminOwnerHandleT (linked to SaImmHandleT)
        SaImmCcbHandleT        (linked to SaImmAdminOwnerHandleT & SaImmHandleT)
        SaImmOiImplemenerNameT (linked to SaImmOiHandleT).

Because the basic handles are allocated and known only by the local IMMND, a
crash or termination of that IMMND will cause the IMMA library instantiations
at the node to mark all its handles as stale. Even global handles allocated via
the crashed IMMND are effectively stale because they depend on the local handles.

The restart of an IMMND should still normally be transparent to the clients
at that node. The IMMA library tries to resurrect the handles once the IMMND
at the node has restarted. In some cases the IMMA will not be able to
resurrect the handle. One example is if the handle is related to an admin-owner
handle with the 'release-on-finalize' option set ot true.
Some clients may then get their handles invalidated. Any attempt by a client
to use such a stale and unsuccessfully resurected handle will result in a
reply of SA_AIS_ERR_BAD_HANDLE.

Note that it is at least not necessary for the client applications to restart.
They may reconnect by simply allocating a new handle. Of course, CCBs that
originated at the node and that where not applied, are aborted. Implementers
need to re-attach. Admin-ownership needs to be reclaimed etc, if you have
allocated a new handle to replace a stale one.

From the perspective of the other nodes, the termination of a remote IMMND is
handled in the same way as if the node it executed on terminated, i.e. the
resources allocated by any client at that node are released. Note however that
such a release of resources by the other IMMNDs is not done immediately or
autonomously by each node. Instead a release order is sent over FEVS.
The actual release is done when the FEVS message arrives at the IMMNDs,
ensuring that all IMMNDs release the resource at the same point in the FEVS
message sequence.

Common missunderstandings about the OpenSAF handles and IMM handles.
--------------------------------------------------------------------
(i) Handles are resources.
OpenSAF client handles in general and IMM handles in particular(SaImmHandleT
and SaImmOiHandleT) are not thread independent. That is, the developer must
avoid using the same handle concurrently from several application threads.
Using different handles from different application threads is of course allowed
and using one handle in different application threads at *different* times
is allowed. In the latter case, the threads typically need to synchronize their
use of the common handle to avoid overlapped use. And they need to understand
the meaning of the term 'use' for the handle. An application thread that is
blocked in a poll that uses a selection object obtained from a handle,
is using that handle even when that thread is not executing.

Each handle should be seen as a resource, which mutates its state
when used by a thread. Part of the resource is a communications channel
to/from the IMMND server. If more than one thread tries to send (synchronously
or asynchronously) or receive (includes waiting for synchronous reply, poll
and dispatch), using the same handle at the same time, the results are
unpredictable. Messages may get lost and a reply may end up at the "wrong"
receiver, the process may crash on assertion in the library.
Each handle is also associated with some heap memory containing a handle
state.

Interleaved use of a handle between several threads is thus possible,
if done correctly. But we strongly recommend against it because any
incorrect use will cause such strange and unpredictable symptoms.

Note that, used correctly(!) OpenSAF libraries are (should be) thread safe.
But thread safe does not mean immune to any and all forms of incorrect use.

(ii) Sub-handles depend on the root handle resources.
An OM-handle (SaImmHandleT) can be used to generate sub-handles such as:

  SaImmAdminOwnerHandleT
  SaImmCcbHandleT
  SaImmSearchHandleT
  SaimmAccessorHandleT

Such sub-handles will share the *same* communication channel towards the
IMMND server. Thus sub-handles to one SaImmHandleT should only be used by
the thread currently using (owning) the root SaImmHandleT.

(iii) Asynchronous admin-operations.
A special case of (ii) is how to program the use of asynchronous admin-
operations. The "vanilla" case is to simply use one thread, both for sending
the asynchronous request and for receiving the asynchronous reply. Both events
of course use the same handle. This is the recommended use if possible.
It is possible when the thread is event driven from a poll. External
requests arrive causing the thread to sometimes send asynchronous admin-
operation requests to some OI. The asynchronous reply from the OI is picked
up by the same poll and typically forwarded out to the external user.
Some form of continuation record would be kept by the requesting thread
to identify the reply.

But in some cases the developer wants to receive the replies on
asynchronous operations in a separate thread from the thread that sent
the request. This is possible, provided that the sending thread somehow
submitts the handle for exclusive use by the receiving thread, immediately
after the send. Until the receiving thread has has received the reply,
the original sending thread should not use the same handle, and it must
not use the same handle for receiving anything (i.e. not poll on a selection
object obtained from that handle and not invoke any synchronous calls using
that handle).

(iv) Blocking & timeouts.
Synchronous downcalls will block the client untill there is a reply.
If there is any resource problem detected in the IMMA library or
in the IMMND server that prevents the request from being processed
currently, then an immediate reply with SA_AIS_ERR_TRY_AGAIN is generated.
The client must be prepared to get the TRY_AGAIN error on any downcall.
The apropriate way to handle TRY_AGAIN is to have a limited loop with
a small delay (at least 10 ms) for each iteration. Preferrably also
increase the delay for each iteration (back off). The client must also
consider the realtime requirements placed on the client itself.
When time spent in the retry loop approaches the realtime limit
placed on the client, then it has to abandon the request.

A synchronous call may also get blocked for a longer time (without getting
TRY_AGAIN) due to resource congestion in the system, or due to slow
processing by one or more OIs, or due a large request such as the apply
of a large CCB. There is a timeout placed on each synchronous downcall,
inside the IMMA library. The default timeout is 10 seconds. This timeout
can be altererd by setting the IMMA_SYNCR_TIMEOUT environment variable
(see below).

There is also a timeout in the IMMND server placed on each OI callback that
is generated. This timeout is currently hard-coded to 6 seconds.
There is an enhancement planned to allow this global timeout value
to be configured (http://devel.opensaf.org/ticket/2021).
If the OI does not reply in time, the server will reply with error to the
client, without waiting for the reply on the callback. Exactly which error is
generated depends on the type of call. Ccb related calls tend to generate
FAILED_OPERATION, i.e. an abort of the CCB/transaction by the server.
But with PBE enabled and congestion at the PBE, the server can not abort
any CCB that is being committed by the PBE. So there is the unfortunate
possibility of getting TIMEOUT on a ccb-apply when applying a CCB with
PBE enabled. TIMEOUT of course means that the client then does not
know if the CCB committed, aborted, or is still being processed.

(v) Return codes from OiCcbCallbacks.
An OI returning a specific error code from a ccb-callback will often
not result in that exact error code being transmitted to and returned by
the originating OM interface. The OI is typically just a participant in
the distributed thing (in space and time) that a CCB/transaction is. Thus
the IMM server consolidates replies from several Ois and must also provide
clear and unambiguous communication of the CCB state towards the CCB end user.
This inevitably results in return codes from Ois being converted by the imm
server to a different singe error code returned to the om-user. The cardinal
example is the ERR_FAILED_OPERATION meaning CCB aborted, resulting from one
or more Ois returning a different specific error on a callback. If the OIs
return error-strings allong with the error code then these error strings
will be provided over the om interface. The OI implementer should therefore
avoid including a specific error code in any error string returned from
a ccb-oi-callback.

Common missunderstandings about attribute defaults.
---------------------------------------------------
Imm class definitions allow the declaration of a default value to be defined
as part of an attribute definition.

(i) A default declaration is only allowed for single valued attributes (no
concept of a multivalued default exists).

(ii) Default values are assigned at object creation. Default values are NOT
assigned if an attribute is set to the empty/null value by a modification.

(iii) Default values are assigned at cluster restart for any attributes that
are null/empty and that have a default. This is a special case of (i) because
imm loading actually uses the regular imm API to recreate the imm contents.
In particular, saImmOmCcbObjectCreate is used to recreate all objects from
the file-system image.

Common missunderstandings about "system attributes" of an imm object.
---------------------------------------------------------------------
Besides the attributes defined in its class, every object also gets assigned
three system attributes (see section 4.2.19 in the SAF IMM A.2.1 spec):

    SaImmAttrClassName - SaStringT - holds the class-name for the object.
    SaImmAttrAdminOwnerName - SaStringT - holds admin-owner (if it exists).
    SaImmAttrImplementerName - SaStringT - holds implemener-name (if it exists).

These system attributes are maintained by the imm service and are not writable
by any Om or OI client. They are readable at any time. The SaImmAttrClassName
attribute is in essence static, since no object can ever change class. It is
also a persistent attribute in that the value is dumped to external format
and the value of course survives cluster restarts.

The SaImmAttrAdminOwnerName and SaImmAttrImplementerName get assigned when/if 
an admin-owner or implementer is set for the object. These attributes are not
full-cycle persistent. That is, a cluster restart will drop their value. For
the SaImmAttrAdminOwnerName attribute, imm-loading always assigns the value
'IMMLOADER'. That admin-owner is special in that it may be overwritten by
anyone setting a new and normal admin-owner for the object. The admin-owner
value 'IMMLOADER' can be used to see if an object has been modified since 
the last cluster restart. For SaImmAttrImplementerName the value will always
be empty/null after a cluster restart.

Note however that both SaImmAttrImplementerName and SaImmAttrAdminOwnerName
are written to export format when the imm is dumped. This can be usefull
for debugging purposes, but the immloader discards these values so that
the system comes up "clean" with respect to admin-owners and implementers.

One conclusion from this is that an OI that is started/restarted must always
invoke not just saImmOiImplementerSet, but also any relevant
saImmOiClassImplementerSet or saImmOiObjectImplementerSet. If the OI only
restarted as a process, the call will be 'idempotent' and succeed quickly.
If the OI is started after a cluster-start then these calls are necssary
to rebuild the implementer-map. See ticket defect ticket #543 for details.
(http://sourceforge.net/p/opensaf/tickets/543)

Minor discrepancy between OpenSAF and SAF on error codes for admin-operations.
------------------------------------------------------------------------------
According to the SAF spec ERR_BUSY should be given as response to an
AdminOwnerRelease/Clear operation if there is currently an admin-operation 
on-going directed at some object that the release/clear is targeting.
But The AdminOwner mechanism is an access-control mechanism, not a concurrency
control mechanism. After access has been granted, in this case for an 
admin-operation, there is no real point in insisting that the admin-ownership
must be valid until the admin-op completes. An AdminOwnerRelease/Clear will
return ERR_BUSY if there is an ongoing CCB, since it is unknown if additional
operations are to be added. Opeartions may be added to the CCB by the OI
itself using the AugmentedCcb interface. With respect to interference
from other overlapping admin-operation requests or other ccb-requests, the
OpenSAF IMM leaves it open to the OI implementation to handle or reject.
The OI dispatch is always via one single thread, but the OI may internally be
multithreaded. It may also postpone reply on an admin-op while taking on other
queued callbacks, since the reply to an admin-op is not done by returning from
the admin-op callback, but by a separate downcall to immsv.



PERSISTENCE
===========
The IMM standard mandates that configuration attributes and persistent runtime
attributes shall be persistent in the sense that such values must survive a
cluster restart and that this must hold for every applied CCB.

The default option for the current implementation of the IMMSv in OpenSAF is
that it does not fully support persistence at the CCB granularity. Instead
it supports persistence at the coarse granularity of dump/backup. Thus the
user must ensure that the IMM is dumped after important changes are made to
such data. The configuration data and persistent runtime data will survive
cluster restart, but only the latest dumped version will be recovered.

One of the main new immsv features available in OpenSAF4.0 is the
Persistent Back-End (PBE). By default this feature is not enabled.
See the instructions below for how to enable it. Use of the PBE
has a signifigant (negative) impact on performance for CCBs and
persistent runtime data, both response time and throughput.
The upside is that the user does not need to do frequent dumps
to get persistence. But it is still advisable to dump the IMM
(to the imm-xml form) periodically, for backup to an external
filesystem, to support recovery from disasters.

-----------------------------------------------

The IMM-PBE feature is an optional feature.
To enable this feature the folowing three steps are needed.

	1) ++++++BUILD WITH PBE+++++++

	In the configure step for OpenSAF enable the pbe:

	./configure --enable-imm-pbe

	You would typically also give other options to configure at the same time.

	Ensure that OpenSAF builds without problems. In particular that it finds
	the sqlite3 include files and the sqlite3 library, which is used by PBE.

	2) ++++++CONFIGURE PBE DEPLOYMENT+++++++++

	Edit 'osaf/services/saf/immsv/config/immnd.conf' or in the
	deployed system typically '/etc/opensaf/immnd.conf'.

	Ensure the IMMSV_ROOT_DIRECTORY points to a shared file system,
	the sqlite3 database file has to be accessible from both controllers!
	In deployment the IMMSV_ROOT_DIRECTORY would typically be set to
	'/var/lib/opensaf/immsv_store'. In the UML simulated deployment,
	this is normally linked symbolically to 'hostfs/repl-opensaf/immsv_store'.

	Define IMMSV_PBE_FILE to the file name of the sqlite3 database file,
	normally 'imm.db'. Note that IMMSV_PBE_FILE must be defined in immnd.conf
	for *all* nodes in the cluster, including payloads, even if they cannot
	access 	the file. The fact that this environment variable is nonempty
	is what tells all nodes that PBE is configured.

	Note also that IMMSV_LOAD_FILE must still also be defined. Even with PBE
	enabled, you typically initial start from an imm.xml file. A restore from
	backup will also typically use an imm.xml file.

	Optionally define IMMSV_PBE_TMP_DIR (see immnd.conf). The PBE sometimes
	needs to regenerate the imm.db file. This is much faster (10 times) if
	the file is generated in a non replicated file system and then copied
	to the replicated file system.

	Initial start the system.
	Ensure that it comes up (that the immsv loads properly from imm.xml).

	3) +++++ENABLE PBE++++++++

	On one of the nodes execute:

	immcfg -m -a saImmRepositoryInit=1 \
	   safRdn=immManagement,safApp=safImmService

	This sets the saImmRepositoryInit attribute in the IMM service
	object to SA_IMM_KEP_RESPOSITORY (1).

	If this immcfg command succeeds, the pbe is runtime enabled and the
	pbe-daemon process should have started and it should have generated
	the first dump to the pbe-file.
	A 'ps' on the controller where the IMMND coord currently resides
	should show something like:

        618 root 22320 S N  /usr/local/bin/immpbed --daemon --pbe /var/lib/..

The PBE feature can at any time be disabled by setting the saImmRepositoryInit
attribute back to SA_IMM_FROM_FILE (2).

	immcfg -m -a saImmRepositoryInit=2 \
	   safRdn=immManagement,safApp=safImmService

The final transaction/CCB done towards the imm.db sqlite file will be to
set the saImmRepositoryInit attribute also in this sqlite file. So any
cluster restart that tries to load from the imm.db file will detect that
PBE is disabled and instead load from the imm.xml file.

Finally, if the PBE is hung for some reason, it can also be forced to
disabled, by the administrative operation:

	immadm -o 100 safRdn=immManagement,safApp=safImmService

This admin-operation will change the value of the above configuration
attribute to 2, i.e. SaImmRepositoryInitModeT value SA_IMM_INIT_FROM_FILE,
without using a ccb and ignoring any currently active PBE.
But this way of disabling the PBE will NOT update the saImmRepositoryInit
attribute in the sqlite file. So any subsequent cluster restart will use
the imm.db file and come up with PBE enabled. So if possible, use the
recommended way, via immcfg, for disabling PBE.


---------------------

SCHEMA CHANGES
==============
OpenSAF 4.1 adds the immsv enhancement of supporting schema changes, that is
changes at runtime to existing class definitions. For more background see
ticket #1310: http://devel.opensaf.org/ticket/1310

The new class definition must of course be valid in itself, i.e. it must
pass all tests that a first version of a class has to pass.
On top of this there are many restrictions that apply to a schema change.

The kinds of change allowed in OpenSAF 4.1 are limited to addition of
new attributes and changes to existing attributes. Removal of existing
attributes are not allowed. Furthermore, not all kinds of additions or
changes are allowed. In general, relaxation changes are allowed while
restricting changes are not.

The following changes are allowed:

ADDITION of new attributes when the 'initialized' flag is not set.

CHANGE of an existing attribute if it is one of the following:

   * Change of default-value for an attribute (config or runtime).
     New instances of the class will get the new default,
     old instances retain the old value.

   * Adding default-value for an attribute (config or runtime).
     New instances of the class will get the new default,
     old instances retain the null value (untill the next cluster restart).

   * Adding 'multivalued' flag for an attribute (config or runtime).

   * Adding 'writable' flag for an attribute (config).

   * Removing 'initialized' flag for an attribute (config).

   * Removing 'persistent' flag for an attribute (runtime).


All other changes, such as change of attribute type, removal of default,
are not allowed.

There is no API change. The existing saImmOmClassCreate_2 call is used
to insert the new class version. The standard behavior is to reject
a class create call with ERR_EXIST if the class name matches an existing class.
This is also still the defalt behavior. But if schema change is enabled,
(explained below), then a new definition for an existing class is
interpreted as an attempt to change that existing definintion.
The implied change is analyzed to ensure that it is an allowed change
according to the above rules. If it is allowed, the new class definition
replaces the old and all existing instances are migrated to the new
representation. If PBE is enabled, the entire change is made persistent.

To enable the non standard schema change support, the following admin
operation must be executed:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:1 \
           opensafImm=opensafImm,safApp=safImmService

This will set the lowest order bit of the 'opensafImmNostdFlags' runtime
attribute inside the immsv. Operation-id '1' invoked on the object
'opensafImm=opensafImm,safApp=safImmService' has the meaning of 'flags-ON'.
The lowest order flag is the allow-schema-change flag which controls the
schema-change behavior. With this flag switched on, the immsv accepts
legal schema changes. If this flag is off, the immsv follows the standard
behavior of rejecting all implied schema changes with ERR_EXIST.

The flag is switched off by a corresponding admin operation. Operation-id '2'
invoked on the object 'opensafImm=opensafImm,safApp=safImmService' has the
meaning of 'flags-OFF'.

        immadm -o 2 -p opensafImmNostdFlags:SA_UINT32_T:1 \
           opensafImm=opensafImm,safApp=safImmService

We strongly recommend that the flag is switched off as soon as any intended
schema change has been completed. This to avoid legal but unintended (!)
schema changes. For example, two applications may accidentally use the
same class name. If the first application is already installed when the
second application arrives and the second application redefines the class
in such a way that it is valid when interpreted as an implied upgrade,
then the class could be upgraded. This could have many unintended
consequences which also could be very hard to troubleshoot. The example
also illustrates the importance of propper prefixing of classnames,
since the class name-space is flat (as opposed to the naming tree
for objects).

If PBE is enabled, the current value of opensafImmNostdFlags can be inspected
via the cached non-persistent runtime attribute 'opensafImmNostdFlags' in the
object  'opensafImm=opensafImm,safApp=safImmService'.
If PBE is not enabled, then this runtime attribute is not accessible, because
there is no regular implementer attached. But the above admin operations are
still handled by the immsv and the schema change behavior is still controlled
the same way.

MULTIPLE APPLIERS (4.2)
======================
http://devel.opensaf.org/ticket/1827
OpenSAF 4.2 adds the immsv enhancement of supporting multiple appliers for
configuration objects. An applier is an OI (object implementer) of lower
rank than the primary OI. The primary OI validates the CCB and has veto
rights to abort any CCB it participates in. If the CCB commits then the
pimary OI will apply the changes into the service/application it represents.
If the CCB aborts then the primary OI discards the changes.

The most signifficant deficiency of having only a primary OI per class/object
is that it is not simple to implement hot-standby solutions.
A hot-standby solution requires the primary OI to inform the standby, by
implementing some form of message protocol at the service/application level.
The concept of an "applier OI" removes this deficiency and allows the
service/application to use the imm to disseminate the changes.

An applier OI registers the same way as the main OI and receives exactly
the same CCB related callbacks as the primary OI. The difference is that an
applier OI does not participate in CCB validation. The imm-service ignores
any reply on the create,delete,modify and completed callbacks, from applier
OIs. An applier OI does not get callbacks for updating runtime attributes.
This should be obvious since admin-ops or updates to runtime attributes
should only be handled by the primary OI. An applier OI is not allowed to
create or delete runtime objects, or to update cached runtime attributes.

The completed callback really has no meaning for the applier interface.
For regular Ois, the completed callback has the purpose of allowing the OI
to validate the changes it received for the CCB. But appliers have no validation
rights. Any error code Returned by an applier from a completed callback is
discarded by the imm service. Note also that the immsv does not wait for
replies from the completed callback on appliers, which means that the CCB is
usually already applied in the imm ram database by the time an applier receives
and processes the completed callback. Thus an applier can not use the completed
callback as a trigger to read the pre-apply version of the objects involved in
the CCB. To acheive that requires the primary OI to communicate with the applier
Oi through some alternate mechanism, before the primary OI returns from the
completed callback. 

The applier OI is thus informed of the same changes as the primary OI
and will be able to apply the changes if the CCB commits and discard them
if the CCB aborts. Exaclty what "apply" here means is up to the application.
The main point here is that it means that the applier has the tools to be
a hot standby, or to perform whatever needs to be done in order to effect
the configuration change that was applied.

There may be any number of appliers for any given class/object. Thus the
applier OI concept may be used not just to solve the "hot standby" problem
but also for the more general problem of effecting the apply of a CCB over
the applications components in the cluster. In the AMF example above, the
osafamfnd processes (node director processes) could in principle also
attach as applier OIs and register any configuration changes that apply
to the specific node.

Another way of stating this is that the applier-OI concept allows IMM
users to leverage the IMM CCB protocol for more than the primary purpose of
that protocol.

The A.02 API is used but the applier concept is only available to an OI
that registers with version A.02.11 (or higher minor version).
An OI-name is recognized as the name for an applier OI by the imm-service
if the first character in the name is '@'. For example, the AMF OI is
named 'safAmfService' and implemented by the osafamfd process at the
active SC. The osafamfd at the standby SC could become more of a hot
standby by registering as the applier OI '@safAmfService'.

As always, only one process/OI-handle may at any point in time be
associated with a particular OI-name. This holds also for applier-OI
names. And as always, an OI-handle may be associated with at most one
implementer/applier-name at a time. So in case of a switch-over (si-swap),
the osafamfd processes would close their current OI-handles (or invoke
saImmOiImplementerClear). Then the osafamfd processes would attach to
either the main OI (safAmfService) or the applier OI (@safAmfService),
using saImmOiImplementerSet.

A word of caution about implementer names. Implementer names are to
be re-used. They are never garbage collected by the imm service.
An implementer-name may have no current live implementer handle attached,
but once created, it lives "forever" ready for the next attach,
(saImmOiImplementerSet). Implementer-names could be compared to Unix port
numbers. A port number on some particular host is (in general)
statically mapped to a service on that host. The service may not always
be up and running, but there should never be any *other* service bound
to the port number. Similarly, an implementer-name is in a given cluster
generally mapped to a service. A service should avoid spawning "dynamic"
implementer names, and avoid incorporating volatile name spaces such as
process-id or time in the name. This may have been obvious for regular
OIs. But with the addition of multiple appliers, there is a risk is that
this is interpreted as an open-ended set of appliers, consuming an open
ended ammount of resources. This would be incorrect design.
An application/service must design for a static set of OIs implying a
static set of OI names, including a static set of applier OIs and
a static set of applier names.

In OpenSAF 5.17.11, a new feature for removing disconnected applies is added
to IMM. The feature can be enabled to remove disconnected appliers from the
cluster after applier timeout expires.

Another difference between regular regular implementers and appliers,
is that regular implementer names and their binding to a set of objects
will survive a cluster restart, whereas applier names and their binding
to objects does not survive a cluster restart. That is, a regular
implementer name is persistent in the face of a cluster restart, as
long as it has been bound to at least one object. But an applier name
is not persistent in the face of a cluster restart, regardless of
whether it has been bound to anything. The main reason for this is
that the regular implementer name is stored with each object in the
special single valued service attribute: saImmAttrImplementerName.

Note here that the binding of a regular implementer-name to a class
(as a result of saImmOiClassImplementerSet) does not survive a
cluster restart. So an application that intends to attach as a class
implementer should always exlplicitly set the class implementer.
If the class implementer is already set, this operation returns
SA_AIS_OK anyway. The "feature" of attachign to an already set
up implementer structure is of dubious value, since the application
must then be aware of its starting context.

Applier bindings are even weaker in this "starting context" sense
because applier bindings to object/class are not synced. The only
applier data that is synced (after a node restart) is the existence of
the applier name and whether ot not any client is currently attached as
that applier.

The most efficient, simplest and normal way to bind an implementer
or applier to objects is by using the saImmOiClassImplementerSet call.
This ensures that the implementer-name is always bound to all instances
of that class. It ensures that the OI will get the saImmOiObjectCreate
callback, which is only possible for class-implementers, since you can
not register with saImmOiObjectImplementerSet on an object that does
not yet exist.

The use of saImmOiObjectImplementerSet is mainly for cases when there
are very few instances of a class and each instance is to be linked
to a an implementer that behaves in a way specific to that instance.

For appliers, attaching as an object-applier could be usefull as a
way of "eavesdropping" on the changes affecting a particular object,
or a few select objects. But invoking saImmObjectImplementerSet
with an applier name, for a large subtree of objects will be much
more expensive in memory than just registering for the class(es)
of these objects.


SUPPORT FOR CCB-OI ERROR STRINGS (4.2)
=====================================
http://devel.opensaf.org/ticket/1904
OpenSAF 4.2 adds the immsv enhancement of supporting ccb error strings
from OI to OM client. Two new API calls are available for this for
clients that register with imm version A.2.11:

(1)
extern SaAisErrorT
saImmOiCcbSetErrorString(SaImmOiHandleT immOiHandle,  /* in */
                         SaImmOiCcbIdT ccbId,         /* in */
                         const SaStringT errorString);/* in */

  Arguments     :  immOiHandle - IMM OI handle
                   ccbId  -  The ccbId for the ccb related callback.
                   errorString - The errorString.

  Return Values :  SA_AIS_OK
                   SA_AIS_ERR_BAD_HANDLE
                   SA_AIS_ERR_INVALID_PARAM
                   SA_AIS_ERR_BAD_OPERATION (not inside valid ccb callback)
                   SA_AIS_ERR_LIBRARY
                   SA_AIS_ERR_TRY_AGAIN
                   SA_AIS_ERR_VERSION  (not using A.2.11)

Allows an OI (not applier) to set an error string in the context of a ccb
related callback. Setting an error string is only relevant if the OI will
return with error (not SA_AIS_OK) on the callback.  The error
string will be transmitted to the OM client. Only one error string
will be accepted per OI callback. Setting additional error strings
in the same OI callback will simply replace the previous one.
Multiple error strings may however be set from different OIs
in different callbacks related to the same OM downcall (e.g.
saImmOmCcbApply). The error SA_AIS_ERR_BAD_OPERATION is returned if the
call is not made from insdie the dynamic context of a valid OI callback.
Setting an error string is only possible inside ccb-oi-callbacks that
have a return code. Thus it is NOT possible inside SaImmOiCcbApplyCallbackT
or SaImmOiCcbAbortCallbackT. For applier OIs, all return values on
callbacks are ignored and an applier OI will get BAD_OPERATION on any
attempt to use this function.

(2)
extern SaAisErrorT
saImmOmCcbGetErrorStrings(
        SaImmCcbHandleT ccbHandle,      /* in */
        const SaStringT **errorStrings);/* out */

  Arguments     :  ccbHandle    - The ccb handle.
                   errorStrings - Pointer to a pointer to a NULL terminated array
                                  of SaStringT. The list of strings is owned by
                                  the imma om library and is cleared/deallocated
                                  in conjunction with the next downcall using the
                                  ccb-handle.

  Return Values :  SA_AIS_OK
                   SA_AIS_ERR_BAD_HANDLE
                   SA_AIS_ERR_INVALID_PARAM
                   SA_AIS_ERR_LIBRARY
                   SA_AIS_ERR_TRY_AGAIN
                   SA_AIS_ERR_VERSION  (not using A.2.11)

Allows the OM client to fetch error strings after the return of a
ccb-related downcall and *before* making the next ccb-related
downcall using the same ccb-handle. If any error string where
set by any OIs involved in the operation that returned with
error, then these error strings should be included in the list.
The imm server discards duplicate strings and allows a maximum
of 128 error strings in the list. Any ccb call that returns
SA_AIS_OK will not have any error-strings.
Only errors that could be returned, directly or indirectly
by an OI, such as FAILED_OPERATION or BAD_OPERATION should
be expected to possibly have an error string.

NOTE: It is very important that the OM client completes its
processing of the errorStrings before invoking the next
ccb downcall using the same ccbHandle. The next such downcall
will free the error strings. If the om user needs the error
strings after re-using the ccbHandle, the user must copy the
strings before such re-use. Note also that the 'errorStrings'
out parameter is declared as 'const', indicating that deallocation
of 'errorStrings' is here done by the library (not the user).


IMPROVED ADMIN-OPERATION API (4.2)
====================================
http://devel.opensaf.org/ticket/1764
Allows the OI to supply a return paramater list in the same way
as the OM client has always been able to supply a parameter list
as part of an admin-operation-invocation. The reply from the OI
is in other respects identical to A.02.01.
Api additions for this are available to imm clients that register
with imm version A.2.11.

Setting version A.2.11 also means that operationId values higher
than SA_IMM_PARAM_ADMOP_ID_ESC (0x8000000000000000LL) have
special meaning and can not be used by the application for its
own purposes. See point 7 below.


(1)
extern SaAisErrorT
saImmOiAdminOperationResult_o2(
        SaImmOiHandleT immOiHandle,                        /* in */
        SaInvocationT invocation,                          /* in */
        SaAisErrorT result,                                /* in */
        const SaImmAdminOperationParamsT_2 **returnParams);/* in */

  Arguments     :  immOiHandle  - Same as saImmOiAdminOperationResult.
                   invocation   - Same as saImmOiAdminOperationResult.
                   result       - Same as saImmOiAdminOperationResult.
                   returnParams - Parameters to return (new for A.2.11)
                                  See A.02.01 spec for the 'params' arg
                                  of saImmOmAdminOperationInvoke_2.

  Return Values : Same as saImmOiAdminOperationResult
                  SA_AIS_ERR_VERSION for the case when
                  saImmOiAdminOperationResult_o2 is used with
                  returnParams!=NULL and *not* with A.2.11 set
                  for the immOihandle.

Allows the OI to reply on the admin-operation with the added list
of return parameters. Works otherwise in the same way as the
original saImmOiAdminOperationResult. If returnParams is set to
NULL then the reply is identical to using the original reply form.
The returnParams argument is constructed in exactly the same way
as the 'params' argument is constructed in
saImmOmAdminOperationInvoke_2.


(2)
typedef void
 (*SaImmOmAdminOperationInvokeCallbackT_o2) (
        SaInvocationT invocation,                          /* in */
        SaAisErrorT operationReturnValue,                  /* in */
        SaAisErrorT error,                                 /* in */
        const SaImmAdminOperationParamsT_2 **returnParams);/* in */

typedef struct {
               SaImmOmAdminOperationInvokeCallbackT_o2
               saImmOmAdminOperationInvokeCallback;
} SaImmCallbacksT_o2;


  Arguments : Same as SaImmOmAdminOperationInvokeCallbackT
              plus the 'returnParam' argument (new for A.2.11).
              See A.02.01 spec for the 'params' arg of
              saImmOmAdminOperationInvoke_2.

Defines a new OM callback that allows asynchronous admin-ops to
receive the added return parameter list. Note that 'returnParams'
is here a 'const' parameter, indicating that deallocation of the
parameter list will be done by the library (not the user).
The deallocation is done after the user returns from the callback.


(3)
extern SaAisErrorT
saImmOmInitialize_o2(
        SaImmHandleT *immHandle,               /* in */
        const SaImmCallbacksT_o2 *immCallbacks,/* in */
        SaVersionT *version);                  /* out */

Arguments	: immHandle - Same as SaImmOmInitialize A.02.01
		  immCallbacks - The new A.02.11 callback.
		  version - Same as SaImmOmInitialize A.02.01

Return values : Same as SaImmOminitialize A.02.01

A new OM-handle-initialize call is needed for supporting the new
callback 'SaImmCallbacksT_o2'. Se the discription of saImmOmInitialize
in A.02.01.


(4)
extern SaAisErrorT
saImmOmAdminOperationInvoke_o2(
        SaImmAdminOwnerHandleT ownerHandle,           /* in */
        const SaNameT *objectName,                    /* in */
        SaImmContinuationIdT continuationId,          /* in */
        SaImmAdminOperationIdT operationId,           /* in */
        const SaImmAdminOperationParamsT_2 **params,  /* in */
        SaAisErrorT *operationReturnValue,            /* out */
        SaTimeT timeout,                              /* in */
        SaImmAdminOperationParamsT_2 ***returnParams);/* out */

  Arguments     :  ownerHandle  - Same as saImmOmAdminOperationInvoke_2
                   objectname   -       -"-
                   continuationId-      -"-
                   operationId  -       -"-
                   params       -       -"-
                   operationReturnValue--"-
                   timeout      -       -"-
                   returnParams - Parameters to return (new for A.2.11)
                                  See A.02.01 spec for the 'params' arg
                                  of saImmOmAdminOperationInvoke_2.

  Return Values : Same as saImmOmAdminOperationInvoke_2,
                  i.e. no new return codes for the A.2.11 version,
                  except SA_AIS_ERR_VERSION for the case when
                  saImmOiAdminOperationInvoke_o2 is used but
                  not with A.2.11 set for the Om-handle.


The synchronous admin-operation downcall. The only difference with
respect to the original saImmOmAdminOperationInvoke_2 is the new
added out parameter 'returnParams'. Note that 'returnParams' is
NOT declared const, indicating that it is the users responsibility
to de-allocate the parameter list. See next point.


(5)
extern SaAisErrorT
saImmOmAdminOperationMemoryFree(
        SaImmAdminOwnerHandleT ownerHandle,          /* in */
        SaImmAdminOperationParamsT_2 **returnParams);/* in */

  Arguments     :  ownerHandle  - Same ownerHandle as used in
                                  saImmOmAdminOperationInvoke_o2
                   returnParams - Same returnParams as used in
                                  saImmOmAdminOperationInvoke_o2

  Return Values :  SA_AIS_OK
                   SA_AIS_ERR_BAD_HANDLE
                   SA_AIS_ERR_LIBRARY
                   SA_AIS_ERR_VERSION  (not using A.2.11)

Allows the OM client to free the memory for returnParams.
The returnParams must have been received from a call to
saImmOmAdminOperationInvoke_o2.

(6)
#define SA_IMM_PARAM_ADMOP_ERROR      "SaImmAdminOperationError"

If an OI intends to reply with an error code (no SA_AIS_OK) as the
result of an admin-operation, then the OI may include an error
string in the list of return parameters. Typically this will be the
only paramteter included when there is an error, but the API allows
any number of parameters to be returned regardless of the return code.
The error string is identified by a parameter with the parameter-name
of SA_IMM_PARAM_ADMOP_ERROR. This is a convention (and not yet
standard). But the convention at least allows for the decoupling of
OM and OI. It allows an independently developed OM client to probe
for an error string when it receives a non OK result.

(7)
#define SA_IMM_PARAM_ADMOP_ID_ESC     0x8000000000000000LL
#define SA_IMM_PARAM_ADMOP_NAME       "SaImmAdminOperationName"

If an OM client sets the 'operationId' to the value of
SA_IMM_PARAM_ADMOP_ID_ESC, then it indicates the intention to
identify the admin-operation using a string name instead of the
numerical operationId. The OM client must then include a parameter
with the name SA_IMM_PARAM_ADMOP_NAME in the paramter list.
The type of this parameter must be SaStringT and the value is the
name of the operation.
This is a convention, but it allows decoupling between the OI
client and OM client in the use of admin-operation names.
In future releases, this convention may also be the basis for
supporting the inclusion of amdmin-operation definitions associated
with an imm-class; and for supporting more elaborate runtime type
checking of admin-operation invocations and replies, by the imm
service.


OI AUGMENTED CCBs (4.2)
====================================
http://devel.opensaf.org/ticket/1963

OpenSAF 4.2 adds the immsv enhancement of supporting OI augmented
CCBs. This feature is available for OI clients that register with
imm version A.2.11.

The basic idea is to allow a configuration object implementer to
add CCB operations to an existing CCB, in the context of create-,
delete-, or modify-callbacks on a configuration object. The OI
then extends the set of changes, originating from an OM client,
that will commit or abort atomically with the original CCB.
This could be seen as a variant of 'database triggers'. In
other words, logic that is triggered by changes initiated
by a client and which extends the set of modifications done by
the transaction.

Warnings.
--------
A note of warning: This feature must be used with prudence
and care by OI designers. The feature allows the OI to add side
effects to a CCB, which the originator of the CCB typically is
unaware of. It may also impact the performance characteristics
of the ccb use-case, or prevent the ccb from being committed,
e.g. by causing timeout of the OM client during processing.
Default timeout for an OM client is 10 seconds. Note also that
the OI-side callback timeout monitoring (by default 6 seconds)
is disabled during an augmentation. OI augmentations to the
same objects operated on by the original OM client could subvert
or interfere with the effect intended by the originating OM client.
The OI should keep the augmentation activity "pure"in the sense of
only doing the ccb-augmentations based on the OIs internal state.
For example, it should not performe extraneous blocking operations
such as invoking synchronous admin-operations during the augmentation. 

The OI designer also needs to take care in avoiding deadlocks
with other OIs. More on this below.

The ideal pattern of use for this feature is when the OI adds
a small ammount of operations that are directed at 'implementation
config objects' private to the OI. The risk for interference with
the intention of the original CCB is then minimal. We are not talking
about runtime data here. It has always been possible for an OI to
add/remove/update runtime objects/attributes as a side effect of the
apply of a configuration change. Runtime data is updated via the OI
API, may be triggered by CCBs, but are not part of CCBs, i.e. not
atomic with them. Runtime data is used by the OI to communicate
information *to* OM clients. Here we are instead talking about
'private configuration data', or configuration data for a sub service,
or related service, that needs to be modified as a side effect of
the original modification and to be part of the atomic commit
of the CCB.

Api
---

The API available to the OI for this feature under IMM interface
version A.2.11 consists of one new synchronous call:

	extern SaAisErrorT
	saImmOiAugmentCcbInitialize(
			     SaImmOiHandleT immOiHandle,          /* in */
			     SaImmOiCcbIdT ccbId,                 /* in */
			     SaImmCcbHandleT *ccbHandle,          /* out */
			     SaImmAdminOwnerHandleT *ownerHandle);/* out */

  Arguments     :  immOiHandle  - The immOiHandle received in the callback.
		   ccbId        - The ccbId received in the callback.
		   ccbHandle    - Pointer to the CCB handle to be initialized.
                   ownerHandle  - Pointer to the administrative owner handle
                                  to be initialized.

  Return Values :  SA_AIS_OK
                   SA_AIS_ERR_BAD_HANDLE
                   SA_AIS_ERR_LIBRARY
                   SA_AIS_ERR_INVALID_PARAM
                   SA_AIS_ERR_BAD_OPERATION (not inside valid ccb callback)
                   SA_AIS_ERR_TRY_AGAIN
                   SA_AIS_ERR_VERSION  (not using A.2.11)

The OI inputs its oi-handle and the ccbId it received in the callback.
In return it gets an OM CCB handle and an AdminOwner handle.
The Imm service has marked these handles as special. They are
only valid for the duration of the callback.

An OI is only allowed to invoke the saImmOiAugmentCcbInitialize call
inside these callbacks:

    SaImmOiCcbObjectCreateCallbackT_2
    SaImmOiCcbObjectDeleteCallbackT
    SaImmOiccbobjectModifyCallbackT_2

It would have been nice to support augmentation also inside the
SaImmOiCcbCompletedCallbackT callback, but since validation is the
purpose of that callback and there may be many OIs involved in the
completion of a CCB, changing the base of validation during
the validation would make validation practically impossible.

The OI augmentation CCB must be 'applied' by the OI before it
returns from the callback in which the augmentation is done.
Such an 'apply' of an augmentation is not the actual final apply,
since that is dependent on the apply of the originating parent CCB.
The 'apply' of an augmentation is only the confirmation from the
OI that the augmentation was completed by the OI.

The typical config OI is already using the OM interface to read its
initial configuration, so all the normal ccb related calls should
already be accessible using the provided ccbHandle. (The OI needs
to include saImmOm.h lexically before the include of saImmOi.h).

If the saImmOiAugmentCcbInitialize call succeeds, the OI can
use the CCB handle to request create, delete, or modify operations,
followed by an apply, or possibly a finalize without apply resulting
in abort.

An abort of the augment CCB by the OI will abort the entire
originating CCB, unless the augmentation was empty at the time of
abort/finalize. The augmentation is empty untill at least one
augmented create, delete or modify operation has succeeded and
no augment operation has failed with SA_AIS_ERR_FAILED_OPERATION.
The FAILED_OPERATION return code, as usual, means abort of *entire*
CCB, not just the operation that resulted in this return code.
And *entire* CCB here means the OM originated parent CCB, not just
the augmented CCB done by the OI. Thus augmented CCBs are not
'nested transactions' in that they can not be aborted with contents,
independently of the parent CCB.

If the OI adds operations to the CCB for objects which it is itself
the implementer for, then it will not receive any OI-callback for
such operations. This is mainly to avoid the OI getting into
deadlock with itself. But it should also not be necessary for
the OI to get such callbacks, since it already has the information
about the changes it itself added. The OI may even create a modify
on the object that is the basis of a create or modify callback it is
executing in. (This should be an unusual case and done with care,
as it is in some sense overriding the 'intention' of the original
client).

It will still be posible for two or more OIs to get into a
distributed deadlock with each other by their use of CCB
augmentation. If such an callback cycle is created, the entire
OM CCB will timeout and be aborted. This could make desirable
and correct configuration changes impossible to commit/apply.

The saImmOiAugmentCcbInitialize call also returns 'ownerHandle'.
This admin owner handle is initialized to the same admin-owner
used by the originating OM client. It can be used by the OI to
set admin-owner for objects the OI intends to modify or delete
and where it does not know that the admin-owner is already set
by the originating OM client, (create operations always get
admin-owner set automatically as part of creation).
The 'ownerHandle' always has 'releaseOwnershipOnFinalize (ROF) set
to true. This is the case even if the original admin owner has it
set to false. If the original admin-owner has ROF==true, then
the augmented CCB actually uses the identical admin-owner. Any
objects operated on by the augmented ccb, are added to the original
admin-owner and will be released whenever the original om user
closes their handle or disconnects. If the original admin-owner
has ROF==false, then the augmented CCB uses a new admin-owner
with the same admin-owner-name and with ROF=true. The release
of the OI augmented admin-owner is done when the parent CCB commits
(is applied). The admin-owner can not be released when the augmented
ccb is applied because the augmented operations are still pending
the apply of the parent ccb.

The OI designer needs to understand that if they set admin-owner
on some objects which already have admin owner set by the original
OM user and the original OM user has releaseOnFinalize as false,
then the OI will cause a release of admin-owner on these objects
which could be a 'surprise' (cause problems) for the OM user.

Again, the OI designer intending to augment CCBs needs to think
carefully about what they are trying to do and why, to avoid
creating an application that appears unmanagable.


Support for SA_IMM_CCB_ALLOW_NULL_OI (4.2)
=========================================
http://devel.opensaf.org/ticket/1997

OpenSAF 4.2 exteds the SaImmCcbFlagsT type with a new flag value:

  #define SA_IMM_CCB_ALLOW_NULL_OI 0x0000000000000100

This flag is available for OI clients that register with
imm version A.2.11.

The flag should be set in *combination* with the existing
SA_IMM_CCB_REGISTERED_OI flag. Its effect is that it relaxes
the requirement on OI to allow no registered OI when there
is no registered implementer *name* for the class/object.
If an implementer name exists, but no implemener is currently
attached, then the semantics is still the same as
SA_IMM_CCB_REGISTERED_OI, the CCB operation is rejected with
SA_AIS_ERR_NOT_EXIST.

This will be the setting hardwired into commands such as 'immcfg'
when invokde in safe mode.

There are then 3 possible flag settings for saImmOmCcbinitialize:

No flags: Allow CCBs to proceed despite missing OIs, regardless
of the way they are missing. This variant is the most unsafe and
should really only be used by special applications such as
immloader. The danger is that an OI that is only temporarily
detached, say during a failover, will not get the opportunity
to validate the CCB. This setting is typically too unsafe.

SA_IMM_CCB_REGISTERED_OI: See the IMM spec for A.02.01.
A CCB operation on an object will only be allowed when there
is an OI name registered for it AND the OI is attached.
This is the most safe way of executing a CCB, but it may be
too restrictive in some cases. The best example is during
installation when some config objects are created before
the OI is started.

SA_IMM_CCB_REGISTERED_OI | SA_IMM_CCB_ALLOW_NULL_OI:
This is the relatively safe variant in the middle.
A CCB operation on an object is allowed if there is an
implementer, or if there is no implementer name defined
for the object.


Support for the environment variable IMMA_SYNCR_TIMEOUT (4.2)
=============================================================
http://devel.opensaf.org/ticket/1808

The IMMA libraries (both OM and OI) have a hard-wired timeout
on synchronous downcalls (to the IMMND), of 10 seconds.

This enhancement changes that to a default timeout, with the
option for the IMMA client to override the default by setting a
value for the environment variable:

            IMMA_SYNCR_TIMEOUT.

The unit of time is 10 milliseconds. Thus the default value
for IMMA_SYNCR_TIMEOUT is 1000 (10 seconds). The minimum allowed
value is 10 (0.1 seconds). Trying to set a value less than 10
will only be interpreted as the value 10.

The 10 second default timeout is a compromize. It is very long for
some applications to be blocked for up to 10 seconds, for example
many OIs can get in trouble with such a long wait.

For other applications, 10 seconds is too short, for example
"immcfg -f huge-batch.xml" with PBE enabled can get ERR_TIMEOUT
during apply (http://devel.opensaf.org/ticket/1786).

Applications with relatively tight realtime restrictions can set
IMMA_SYNCR_TIMEOUT to a low value, avoiding the risk of getting
blocked for 10 seconds, but with an increased risk of getting
ERR_TIMEOUT on synchronous calls.

Some batch operations, particularly deletes of large subtrees of
imm data, where one delete downcall is expanded into a cascade of
deletes of objects in the subtree, can benefit from setting
a high value on IMMA_SYNCR_TIMEOUT.

The IMMA library samples the IMMA_SYNCR_TIMEOUT environment variable
at OM/OI handle initialize. The handle is stamped with the value of
of IMMA_SYNCR_TIMEOUT (if it exists), at the time of handle create.

This means that the timeout can not be altered for every individual
downcall. But it also means that one process may have different
timeouts set for different handles. Sub-handles (ccb, admin-owner,
iteration, accessor) inherit the timeout value of their associated
om-handle.

Support for search with SA_IMM_SEARCH_GET_CONFIG_ATTR (4.3)
=============================================================
http://devel.opensaf.org/ticket/1897

The IMM A.2.11 API included an added flag value for the SaImmSearchOptionsT
type for requesting only config attributes: SA_IMM_SEARCH_GET_CONFIG_ATTR.
This feature did not make it into OpenSAF 4.2, but will now instead be part
of OpenSaf 4.3.

The IMM API version where this is implemented is now IMM A.2.12 in OpenSAF(4.3)

The main driver for this feature is the very common need for an OI implementation
to fetch the initial configuration, without also asking for the values of
runtime attributes. If an OI performs a read-request (over the OM API) that
includes pure runtime attributes for which it itself is the implementer, then
the OI will currently get into deadlock with itself (if the OI is not multihreaded).

For cached runtime attributes this problem does not exist, but typically the OI
is not interested in fetching its own cached runtime attributes, which means
a waste of memory and execution.

The problem has been that the only way for the OI to only fetch its config
attributes, is to explicitly enumerate all the config attributes it wants
to fetch.

This new feature will make it much simpler for the OI to express this
common type of query.

The SA_IMM_SEARCH_GET_CONFIG_ATTR can either be used in the obvious way
by using it in a saImmOmSearchInitialize_2 request.

For requests of a specific object, the saImmOmAccessorGet_2 api is simpler,
but that API does not have any searchParameters argument.
This enhancement still supports the GET_CONFIG_ATTR feature also for
saImmOmAccessorGet, by what may be called a "hack" or a convention.
If the 'attributeNames' parameter to saImmOmAccessorGet_2 has only one
attributeName with the string value: "SA_IMM_SEARCH_GET_CONFIG_ATTR",
then the immsv implementation will interpret this as request for all
config attributes and NOT as a request for the attribute named
"SA_IMM_SEARCH_GET_CONFIG_ATTR".

The SA_IMM_SEARCH_GET_CONFIG_ATTR feature should work over immutils and
immutills also has an added wrapper for the saImmOmAccessorGet_2 use
that encapsulates the convention solution just described.
The new function added to immutils has the signature:

extern SaAisErrorT
immutil_saImmOmAccessorGetConfigAttrs(SaImmAccessorHandleT accessorHandle,
                                      const SaNameT *objectName,
                                      SaImmAttrValuesT_2 ***attributes);


Support for redundant data export special applier OI (4.3)
==============================================================================
http://devel.opensaf.org/ticket/2873
http://devel.opensaf.org/ticket/2883
http://devel.opensaf.org/ticket/2892

The 'special applier' enhancement implemented in OpenSAF 4.3 is a mechanism
intended to assist the replication of chosen parts of the imm database to
a generic receiver external to the imm service.

As the name implies, it uses the same OI interface that regular appliers use.
The difference is the way the subset of imm data to be sent to the applier
is configured and that cached runtime data may be included.

Regular appliers (and OIs) will get callbacks depending on which classes or
objects they have explicitly registered for, using saImmOiClassImplementerSet
or saImmOiObjectImplementerSet. This is a two level mapping:

        oiHandle->implementerName
        implementerName->classes/objects

The two level maping does not survive cluster restarts (it is not persistent),
but the second level mapping survives disconnect at the first level. Thus the
bindings related to an implementerName survives process termination or
oiHandle close.

Regular appliers (and OIs) are typically application specific, listening only
for changes on config data that is relevant to their application.

The special applier is generic. It does not use saImmOiClassImplementerSet or
saImmOiObjectImplementerSet to set up the second level map. Instead it
will receive callbacks for objects with attribute values if the attribute
definition in the class definition for the object has the SA_IMM_ATTR_NOTIFY
flag set to on.

The IMM A.2.12 API extension supported in OpenSAF 4.3 reserves a new flag value,
labeled:

        SA_IMM_ATTR_NOTIFY

in the SaImmAttrFlagsT type. The SaImmAttrFlagsT type is used when defining
attributes as part of an imm class definition.

The meaning of this new flag is that, if it is on, then any change to the value
of that attribute in any instance (imm object) of that class, will generate a
callback for any attached special appliers. Because the flag is associated with
class definitions, it is persistent. Toggling the flag on an attribute definition
is in principle an imm schema change (see SCHEMA CHANGE section above). It is an
update of a class definition. Since class definitions are persistent, the special
applier second level mapping implementerName->class/attributes will survive a
cluster restart. This is also necessary since there exists no regular implementer
that can set up the second level binding dynamically at cluster start.

For the first level mapping oiHandle->implementerName, the special applier is
currently fixed to only allow two "magic" applier names:

        #define OPENSAF_IMM_REPL_A_NAME "@OpenSafImmReplicatorA"
        #define OPENSAF_IMM_REPL_B_NAME "@OpenSafImmReplicatorB"

These applier names are "magic" in the sense that the imm service will recognize
these names as special and generate the special applier callbacks to them if
they are attached. The limitation to two names may be relaxed in the future if
needed. The current vision is that only one logical replicator is needed
because the service is generic. The generic replicator may then push the data
on to a tracking service (such as Ntf) that in its turn allows multiple
consumers. The generic replicator may even itself push the data on to more than
one outgoing communication service. Thus there should typically not be needed
more than one logical replicator.

The reason for two special applier names instead of just one, is to allow a
logically unique replicator to be implemented redundantly as an active/standby
pair. If only one special applier name would be used, then there would be an
inevitable gap in time after the current active detaches and the new active
attaches. An applier or implementer name can at most be attached to one
oi-handle in the cluster, at any given time. Thus the standby special applier
needs to receive the same callback stream as the active, using a distinct
special applier name, but will discard the data based on information it
receives from the active (e.g. via message based checkpoint).

Having both special applier names attached at the same time on the same node
should be avoided. The imm service will only generate the special applier
callbacks towards one special applier at one node at any point in time. Thus
only one of them will receive the special applier callbacks if both are
attachhed on the same node. It is implementation dependent which one.

The SA_IMM_ATTR_NOTIFY flag may be toggled using immcfg (#2892), or as part
of a regular schema change in an SMF campaign. Export/import of the new flag
to imm xml format is supported by immdump/immload (#2883).

Although the special applier uses the same SaImmOi callback interface as regular
implementers and regular appliers, there are some special rules concerning the
contents of the parameters provided from the imm service.

----------------------------

Config data is changed using Ccb's and the special applier will get the same
sequence of operational callbacks (create/modify/delete) followed by completed
and apply. For the operational callbacks the following apply:

SaImmOiCcbObjectCreateCallbackT_2 will contain attribute values for *all*
attributes that have the SA_IMM_ATTR_NOTIFY flag on. The attribute value may have
been set explicitly by the om-client in the ceate downcall, or the value may be
the default value for the attribute, or the value may be the empty value.
In addition, the callback will contain the Rdn attribute and the system attributes
named SaImmAttrClassName and SaImmAttrAdminOwnerName. The Rdn attribute is
necessary even if it is not flagged as notifiable, since the special applier needs
it for constructing the DN for the object to be created. The class-name and
admin-owner name are needed for the special applier, or its downstream clients, to
interpret what kind of object is being created and who is creating it.

SaImmOiCcbObjectModifyCallbackT_2 will contain only attribute values that have
been modified in this operation *and* that have the SA_IMM_ATTR_NOTIFY flag on.
In addition, the callback will contain the system attributes SaImmAttrClassName.
The system attribute SaImmAdminOwnerName will also be included if the value
has not been provided already in a previous callback for the CCB. Thus if a prior
create or modify has been sent then the current modify will not add the admin-
owner system attribute. Admin-owner never changes for a CCB.
The class-name may be needed if the special applier attached after the object
was created and had not yet initialized by reading from the imm. Indeed it is
left open to the implementor of the special applier to decide how and even if
they should initialize by reading from the imm. The admin-owner allows the
receiver to interpret who is modifying the object.

SaImmOiCcbObjectDeleteCallbackT can obviosly not contain any attribute values.
Only the DN of the object to be deleted is provided, since that is how the
callback is defined. However, the imm service guarantees that a CCB that
contains delete callbacks, will also contain at least one modify or create
callback containing at least the SaImmAdminOwnerName system attribute.
For any ccb (where ccb != 0), the first special applier callback is guaranteed
to hold the admin-owner-name. If the first operation is a real create or modify
then that will hold the admin-owner-name. But if the first operation in the real
ccb is a delete-operation, then the immsv will first generate a fake modify to
the special applier, using the same object/dn to be deleted, containing the
admin-owner-name. After the fake modify, the real delete will be generated
towards the special applier.

This allows the receiver to interpret who is deleting the objects. The class-name
for the object should not be needed since if the receiver is already aware of the
object to be deleted, then they should already know the class for that object
and if they are not aware of the object, then they can simply discard the delete
operation since it is a delete of an object that the receiver does not have.

The SaImmOiCcbCompletedCallbackT, saImmOiCcbApplyCallbackT and
SaImmOiCcbAbortCallbackT have exactly the same semantics as always. The completed
callback is typically ignored by appliers.

----------------------------

Cached runtime data is created/updated and deleted by an implementer/OI. Each such
OI downcall operation will generate only the single corresponding OI callback on
the special applier, but with the ccbId parameter set to *zero*. No completed,
apply or abort callbacks are generated for cached runtime data operations. Persistent
runtime data is always also cached, so the same rules apply for persistent runtime
data. Non-cached runtime attributes are not allowed to have the SA_IMM_ATTR_NOTIFY
flag set.

SaImmOiCcbObjectCreateCallbackT_2 will contain attribute values for *all* cached
runtime attributes that have the SA_IMM_ATTR_NOTIFY flag on. The attribute value
may have been set explicitly by the OI in the ceate downcall, or the value may be
the default value for the attribute. Cached runtime attributes without default
value must get a value provided by the OI in a saImmOiRtObjectCreate_2 call.
In addition, the callback will contain the Rdn attribute and the system attributes
named SaImmAttrClassName and SaImmAttrImplementerName. The Rdn attribute is
necessary even if it is not flagged as notifiable, since the special applier needs
it for constructing the DN for the runtime object to be created. The class-name and
implementer name are needed for the special applier, or its downstream clients, to
interpret what kind of runtime object is being created and who (what implementer)
is creating it. The ccbId parameter will be zero.

SaImmOiCcbObjectModifyCallbackT_2 will contain only cached runtime attribute values
that have been updated in this operation *and* that have the SA_IMM_ATTR_NOTIFY
flag on. In addition, the callback will contain the system attributes
SaImmAttrClassName and SaImmImplementerName. The class-name may be needed if the
special applier attached after the object was created and had not yet initialized
by reading from the imm. Indeed it is left open to the implementor of the special
applier to decide how and even if they should initialize by reading from the imm.
The implementer-name allows the receiver to interpret who is updating the runtime
attributes. Note that the object containing the cached runtime attributes may be
either a runtime object or a config object. This since config objects may contain
runime attributes. The ccbId parameter will be zero.

SaImmOiCcbObjectDeleteCallbackT can obviosly not contain any attribute values.
Only the DN of the object to be deleted is provided, since that is how the
callback is defined. For runtime object deletes, the imm can not provide any
'fake' modify callback to provide class-name and implementer-name. This is because
runtime data is not operated on using Ccbs/transactions. So there is no way to
group and corelate several operations as belonging to the same ccb. But the
class-name for the runtime object should not be needed since if the receiver is
already aware of the runtime object to be deleted, then they should already know
the class for it and if they are not aware of the runtime object, then they can
simply discard the delete operation, since it is a delete of an object that the
receiver does not have. Similarly, the implementer-name should not be needed.
Unlike admin-owner-name, which may be different for different ccbs operating on
the same config object during its life cycle, implementer-name will never change
for a runtime object. The ccbId parameter will be zero.


Support for attribute definitions with SA_IMM_ATTR_NO_DUPLICATES (4.3)
======================================================================
http://devel.opensaf.org/ticket/1545

The IMM A.2.11 API included an added flag value for the SaImmAttrFlagsT type
used in attribute definitions for class create: SA_IMM_ATTR_NO_DUPLICATES.
This feature did not make it into OpenSAF 4.2, but will now instead be part
of OpenSaf 4.3

The IMM API version where this is implemented is now IMM A.2.12 in OpenSAF(4.3)

This can only be set in conjunction with the SA_IMM_ATTR_MULTI_VALUE flag.
The effect of setting also the SA_IMM_ATTR_NO_DUPLICATES flag is that the
attribute behaves as a 'set' instead of as a 'bag'. The SAF IMM standard
defines multivalued attributes very loosely as attributes that may have many
values. Nothing is said about uniquenes of values, hence duplicates must be
allowed. In most cases the intention with a multi valued attribute is likely
to be to not have duplicate values. It is now possible to get this more
restricted semantics by settign the SA_IMM_ATTR_NO_DUPLICATES_FLAG.

It is possible to add the NO_DUPLICATES flag to a MULTI_VALUE attribute
definition in an existing class, via a schema change. But such an upgrade
will only succeed if no current instances of the class have duplicates in
this attribute. The imm service will perform a runtime check of this before
allowing the upgrade. Application maintainers that intend to use this flag
need to consider the fact that adding the flag may cause an upgrade campaign
to fail due to site specific values on such multivalued attributes.

There is a reason why the imm service does not go one step further and
consolidate duplicates instead of just check and reject upgrades that
encounter duplicates. If the imm service where to do such consolidation,
it would mutate the values of application data without informing the OI
of such changes. We dont see that as acceptable and predictable behavior.
The approach taken is instead to make it the applications responsibility to
eliminate duplicates before the schema change attempt, possibly as a prior
application step in the campaign.


IMMA_MAX_OPEN_SEARCHES_PER_HANDLE (4.3)
==============================================================
http://devel.opensaf.org/ticket/2977
http://devel.opensaf.org/ticket/3036

A relatively common error in imm applications is to omitt closing of
search handles or accesor handles. This results in a "resource leak"
which will be removed only if/when the application closes the om-handle
under which the search/accessor handles where created, or when the
application terminates.

Such resource leaks will manifest themselves as increasing use of memory
in the local IMMND server. How large such leaks will be depends on the
applicaiton behavior. But if a search is initialized for iteration over
a large part of the imm database and is dropped before it is consumed,
then very large ammounts of memory could remain allocated.

To make early detection of such resource leaks possible, a limit on
the maximum number concurrently allocated search handles per om handle
has been introduced in OpenSAF 4.3.

A default maximum of 100 concurrently open search handles per om-handle
are allowed. That is, at most 100 open handles of type SaImmSearchHandleT
or SaImmAccessorHandleT created using the same SaImmHandleT are allowed.
This limit, associated with each om-handle, is checked by the imma library
each time a search/accessor handle is created.

Applications that have special and legitimate needs to provide many
concurrent imm searches, can change the limit from the default value.
The application does this by setting a higher value on the environment
variable IMMA_MAX_OPEN_SEARCHES_PER_HANDLE.

Applications can also avoid the limit by using more than one om-handle
as the root resource for allocating search handles. For applications
that legitimately need several hundred concurrent search handles,
we recommend this solution rather than raising the limit per om-handle,
as it is more efficient in server processing. It also allows the searches
to be controlled by more than one client thread.

It may also be usefull for applications to *lower* the value in early
testing. This increases the chances that application resource leaks are
detected early in development.

The IMMA library samples the IMMA_MAX_OPEN_SEARCHES_PER_HANDLE environment
variable at OM handle initialize. The om-handle is stamped with the value
of this variable, if it exists, at the time of handle create.

There is also a much higher sanity limit defined on the server side.
Currently defined as 5000 open searches per om-handle. That limit is
not configurable.


Optimize subtree search           (4.3)
==============================================================================
http://devel.opensaf.org/ticket/1844


Allow saImmOiImplementerSet during imm-sync       (4.3)
=======================================================
http://devel.opensaf.org/ticket/1871


Catch some cases of thread interference over handles    (4.3)
=============================================================
http://devel.opensaf.org/ticket/1984


Pbe & immload uses pre-compiled & parametrized queries  (4.3)
=============================================================
http://devel.opensaf.org/ticket/2467
http://devel.opensaf.org/ticket/2696


immcfg -L validate imm-xml file as xml loadable  (4.3)
======================================================
http://devel.opensaf.org/ticket/2766


AdminOp gets TRY_AGAIN if OI is transiently detached (4.3)
==========================================================
http://devel.opensaf.org/ticket/2593


IMM server must protect itself from invalid data received from imm clients (4.3)
================================================================================
http://devel.opensaf.org/ticket/2747

IMMNDs should subscribe in normal mode towards IMMD (4.3)
=========================================================
http://devel.opensaf.org/ticket/2446

saImmOiImplementerClear can avoid exposing a stale oi-handle (4.3)
==================================================================
http://devel.opensaf.org/ticket/2465

immdump should be split into a tool and a daemon (4.3)
======================================================
http://devel.opensaf.org/ticket/2835


Notes on upgrading from OpenSAF 4.1/4.2 to OpenSAF 4.3
======================================================
Enhancement #1871 opens up for allowing saImmOiImplementerSet during imm-sync.
This more liberal behavior does not work well during upgrade from earlier
OpenSAF releases to the OpenSAF 4.3 release. See ticket #3071.

Because of this upgrade problem, the older more restrictive behavior is still
enforced in OpenSAF 4.3 unless a flag is turned on in the opensafImmNostdFlags
runtime attribute in the object: opensafImm=opensafImm,safApp=safImmService.
The following is the shell command:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:4 \
           opensafImm=opensafImm,safApp=safImmService

This will set the third bit of the 'opensafImmNostdFlags' runtime attribute
inside the immsv. Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

has the meaning of 'flags-ON'. Operation-id '2' has the meaning of 'flags-OFF'.
This flag needs to be turned ON when the upgrade to OpenSAF 4.3 has been
successfully completed. Thus in the final steps of the upgrade. A cluster
start/restart of an OpenSAF4.3 system will always automatically turn on
this flag. 

2PBE Allow IMM PBE to be configured without shared file system (4.4)
===================================================================
http://sourceforge.net/p/opensaf/tickets/21/
OpenSAF 4.4 adds the enhancement of supporting 2PBE.
The 2PBE enhancement allows the IMM to have PBE configured so that it
does not rely on a shared filesystem, such as DRBD.

See: osaf/services/saf/immsv/README.2PBE for details.

immadm supports argument for explicitly setting admin-owner (4.4)
================================================================
http://sourceforge.net/p/opensaf/tickets/613/
http://sourceforge.net/p/opensaf/tickets/642/

This was actually fixed as a defect made visible by the 2PBE enhancement.
The IMM service takes stronger ownership of the OpenSAF Imm service object
mentioned earlier:

        'opensafImm=opensafImm,safApp=safImmService'

by more or less permanently setting adminOwner for this object to be
safImmService. The 'immadm' command has been fixed to be aware of this more
strict ownership on this particlar object and will automatically use the
admin-owner 'safImmService' when requested to operate on this object.
Normal OM API users should not notice any effect of this change.

Support for reference integrity checking - SA_IMM_ATTR_NO_DANGLING (4.4)
========================================================================
http://sourceforge.net/p/opensaf/tickets/49/
OpenSAF 4.4 adds the immsv enhancement of supporting referential integrity
checking. The feature is available for clients that register with imm API
version A.2.13.

A new attribute definition flag has been defined:
#define SA_IMM_ATTR_NO_DANGLING   0x0000000004000000

See: osaf/services/saf/immsv/README.NO_DANGLING for details.

Support search for objects having NO_DANGLING refrence to a target (4.4)
========================================================================
http://sourceforge.net/p/opensaf/tickets/50/
OpenSAF 4.4 adds the immsv enhancement of supporting search/iteration
for finding all objects that have a NO_DANGLING reference to a provided
target. This feature is available for clients that register with imm API
version A.2.13.

See: osaf/services/saf/immsv/README.NO_DANGLING for details.


Support for saImmOmCcbAbort() and saImmOmCcbValidate() (4.5)
========================================================================
http://sourceforge.net/p/opensaf/tickets/798/

Adds support for an OM client to explicitly request abort of the current
CCB(id) without finalizing the handle.
Also support for an OM client to explicitly request validation of the current
CCB state without any immediate and automatic ccb commit if validation succeeds.

These API additions are available to OM clients that initialize their OM-handle
with IMM API version A.2.14.

(1)
extern SaAisErrorT
saImmOmCcbAbort(SaImmCcbHandleT ccbHandle): /* in */

  Arguments     :  ccbHandle  - The ccbHandle for the ccb to be aborted.

  Return Values :  SA_AIS_OK

                   SA_AIS_ERR_BAD_OPERATION - Not allowed inside a ccb augmentation.

                   SA_AIS_ERR_VERSION  (not using A.2.14)

                   Returncodes otherwise identical to saImmOmFinalize.

Aborts a CCB(id) without finalizing the ccb-handle.
Discards any ccb operations currently associated with the ccb-handle.
Also resets a ccbHandle that has previously received the abort return
code SA_AIS_ERR_FAILED_OPERATION. 
Previously it was only possible to explicitly abort an active ccb
by invoking saImOmCcbFinalize() which also closes the ccb-handle.
And previously it was not possible to reset a ccbHandle that had
received the ccb-aborted return code: SA_AIS_ERR_FAILED_OPERATION.
Such a ccb-handle was doomed and could only be finalized. This is
no longer the case when the ccbAbort alterative exists. Invoking
ccbAbort is an explicit handshake between the om-user and the immsv
that any previous ccb-state is cleared and the current ccb-state is
empty. If SA_AIS_OK is returned then ccb-handle can continue to be
used and is in the same empty state as if it had just been initialized.                   
This is a blocking synchronous call.

(2)
extern SaAisErrorT
saImmOmCcbValidate(SaImmCcbHandleT ccbHandle): /* in */

  Arguments     :  ccbHandle  - The ccbHandle for the ccb to be validated.

  Return Values :  SA_AIS_OK - Validation succeeded. Ccb has *not* been
                               committed. No additional operations can now
                               be added to the current ccb(id). This ccb(id)
                               can now be aborted or an attempt can be made
                               to commit it using saImmOmCcbApply().

                   SA_AIS_ERR_FAILED_OPERATION - Validation failed, the ccb
                               can now only be aborted, using either 
                               saImmOmCcbAbort() or saImmOmCcbFinalize().

                   SA_AIS_ERR_BAD_OPERATION - Not allowed inside a ccb augmentation.

                   SA_AIS_ERR_VERSION  (not using A.2.14)

                   Returncodes otherwise identical to saImmOmCcbApply().

Performs only the validation part of a regular saImmOmCcbApply().
All involved OIs receive the completed-callback and perform their
validations. If validation fails (FAILED_OPERATION) then the ccb(id)
is in the same aborted state as if validation had failed during a
saImmOmCcbApply(). But if validation succeeds (SA_AIS_OK) then the
OM client has the option to either commit the CCB using saImmOmCcbApply()
or to abort the CCB using either saImmOmCcbFinalize() or saImmOmCcbAbort().
The OM client can not add new operations to a CCB that has been validated. 
The saImmOmCcbValidate call is suitable for clients that wish to perform
incremental validation. This can be achieved by validating a CCB, aborting
it then replaying the same operations (that validated), followed by adding
more operations. Replay is necessary because the OIs ccb-protocol can only
cope with one invocation of validation (completed callback) for any given
ccb-id. Another possible use is in integrating IMM transaction commit
with the commit of some other transaction handling system. By validating
without committing, the risk is significantly reduced that a final
commit/apply will fail. The invocation of saImmOmCcbApply after a 
successfull invocation of saImmOmCcbValidate can still fail/abort,
but only due to resource problems (such as server crash or filesystem
unavailability). 

This is a blocking synchronous call.


Allow admin-operations directly targeting an implementer or applier (4.5)
======================================================================
http://sourceforge.net/p/opensaf/tickets/799/


The existing IMM admin-operation API in OpenSAF:

    saImmOmAdminOperationInvoke_2()
    saImmOmAdminOperationInvoke_o2()
    saImmOmAdminOperationInvokeAsync_2()
    SaImmOmAdminOperationInvokeCallbackT()
    SaImmOmAdminOperationInvokeCallbackT_o2()

    SaImmOiAdminOperationCallbackT_2()
    saImmOiAdminOPerationResult()
    saImmOiAdminOperationResult_o2()

allows OM clients to invoke procedural requests directed at an imm object.
The OM client needs to have an admin-owner handle associated with an admin-owner
name that matches the admin-owner for the object. The actual target/receiver of
the admin-operation is really the implementer/OI registered for the object or
class. The object that anchors the request is effectively a parameter in the
request to the OI.

This enhancement (#799) does not add any new API. It extends the allowed scope
for the existing admin-operation API to cover the case where the target is an OI
directly. Instead of supplying the DN of an object as the address/target, an
implementer-name is provided as the address/target. This allows the OM client to
invoke admin-operations directly and explicitly on an OI. The implementer-name
is used as a proxy for the object-name in the admin-operation API.

Because the extended scope does not require the addition of any new API, access
to this extension is not based on the handle version used. But the enhancement
is introduced in OpenSAF release 4.5 and thus only available in that release or
later releases. 

The om-side admin-operation-invoke call takes an admin-owner-handle as argument.
The admin-owner handle needs to be an initialized handle and it must set the
admin-owner-name to be the *same* as the implementer-name. This may seem peculiar
and unnecessary. But it serves both as a confirmation that the OM client has not
made some mistake in using the new extended scope; and as a possible future
entry point for authorizing admin-operation access directly targeting the OI. 

The main benefit of this extension of scope, is that it allows a simple way for
applications to set up cluster scoped remote procedure call communication, where the
request arives FEVS-synchronously at the target. FEVS is the cluster synchronized
messaging mechanism used by the Immsv (see earlier in this README).

The receiver process only needs to register as an implementer or applier with IMM.
In many cases the receiving process has done this anyway for other reasons.
The sender only needs to know the name of the implementer/applier, the operation-id
and expected arguments for the call. For this extended scope usage, the OI does not
necessarily need to be the real implementer/OI for *any* imm object at all.

Another use case is that it allows an om-client to communicate with (or probe) an
OI/applier as such. An OI may be the OI for many objects and classes. In some cases,
requests for information, or requests for adjustments in behavior of the OI/applier
are generic and not associated with any specific object. For example, statistics or
resource utilization data, last processed ccb, for the OI or Applier.

Appliers are only listeners/trackers of ccb changes. An applier is never reachable
via any *regular* admin-op invoked via some object. This since the applier will never
be *the* OI for any object. But this enhancement allows an OM client to communicate
directly also with appliers. This can for example be usefull if a main-OI needs
an applier to read the before-ccb-commit versions of objects being changed in a CCB.
The main OI can achieve this by sending a synchrnous admin-op to that applier from
inside the completed callback for the main OI. Because the main-OI has not returned
from the completed callback, the apply of that CCB is suspended waiting on the reply
on the completed callback. Once the applier has read the before-image data, from
inside the admin-op callback, it replies on the admin-op towards the main OI. The
main OI can then finish the validation and reply to the immsv. Note that the main OI
is in this example using both the OI and the OM API concurrently.

One note of warning. Care needs to be taken when using *synchronous* admin-operations 
not to create deadlock cycles between the involved processes. Any such deadlock will
be resolved by the timeout of the synchronous admin-ops, so the problem would be lack
of progress on some task, not a permanently hung set of processes.

Support for long DNs in existing IMM APIs (4.5)
===============================================
http://sourceforge.net/p/opensaf/tickets/886
http://sourceforge.net/p/opensaf/tickets/957/
This enhancement is part of the general enhancement for supporting long DNs in
OpenSAF tracked by ticket: #191. Ticket #886 adds support for long DNs to IMM.

The long DN enhancement results possibility that the error code:

     SA_AIS_ERR_NAME_TOO_LONG 

can be returned by the following APIs:

    saImmOmSearchInitialize_2
    saImmOmSearchNext_2
    saImmOmAccessorGet_2
    saImmOmAdminOperationInvoke_2
    saImmOmAdminOperationInvokeAsync_2
    saImmOmAdminOperationInvoke_o2

or be returned in the parameter 'error' by the following callbacks:

   SaImmOmAdminOperationInvokeCallbackT
   SaImmOmAdminOperationInvokeCallbackT_o2

This error will be returned if:

 - The OM request contains a long DN and the OI is not long DN capable.
 - The reply (from imm-server on search, or from OI on admin-op) contains
   a long DN and the OM-client is not long DN capable.


The library implementation of the existing IMM API has been addapted to the 
"tunneling" solution  provided by the OpenSAF generic patch for ticket #191.
See the document: 

        OpenSAF_Extensions_PR.odt 

on how to use the SaNameT tunneling primitives, allowing DNs longer than 255 bytes 
to be passed via an SaNameT value.

A new IMM API where all use of SaNameT is replaced by SaStringt and SaConstStringT
has been reviewed and accepted by the OpenSAF TC. But support for this new API
did not make it into OpenSAF 4.5. Instead it will be provided in OpenSAF 4.6.
This is tracked by ticket #643 (http://sourceforge.net/p/opensaf/tickets/643).

An unofficial API similar to #643 has been provided in OpenSAF4.5  as part of
immutils (ticket #957). The immutils library uses 'char *' and 'const char *'
instead of SaStringT and SaConstStringT. The immutils library source code is 
available for copying under the directory:

  samples/immsv/immutils

The additions to the immutils API encapsulates use of the SaNameT tunneling over
the IMMA lib. It can be seen as an example of how to use SaNameT tunneling, or it
can be copied and incorporated into an application library with the understanding
that it is part of, maintained, and versioned by each such application. 


Attribute 'longDnsAllowed' added to class 'OpensafImm' (4.5)
===========================================================
http://sourceforge.net/p/opensaf/tickets/897

This enhancement is part of the general effort for supporting long DNs in
OpenSAF tracked by ticket: #191 and adding support for long DNs to IMM tracked by
ticket: #886.

A config attribute named 'longDnsAllowed' is added to the class 'OpensafImm' and
is available in the only instance of that class: 

   opensafImm=opensafImm,safApp=safImmService

The default value is 0 with the intended meaning that long DNs are not allowed.
Any other value has the meaning that long DNs are allowed. The attribute is checked
as part of processing any IMM request that would imply the usage of a long DN. 

Transitioning from true to false/0 for this attribute will only be allowed at a site
if the imm database at the site currently has no long DNs.

An imm xml file containing the extended class definition for OpensafImm has been
added at:

        samples/immsv/OpensafImm_Upgrade_4.5.xml.

That xml file should be used for upgrading the class when systems running older 
OpenSAF releases are upgraded to OpenSAF 4.5 and that system needs to be capable
of supporting long DNs. An initial start of a pristine OpenSAF 4.5 ssytem will
automatically install this new attribute. 


SAF RDN limitation of 64 characters made conditional on 'longDnsAllowed (4.5)
=============================================================================
http://sourceforge.net/p/opensaf/tickets/23/

If support for long DNs is enabled (by setting the longDnsAllowed attribute to
a non zero value) then this will also disable the 64 byte limit on RDN length in
that system.


Add OI functionality for the IMM service to validate its own config data (4.5)
==============================================================================
http://sourceforge.net/p/opensaf/tickets/934/
http://sourceforge.net/p/opensaf/tickets/951/

Prior to OpenSAF 4.5 there was really no IMM OI implemented. The IMM service
has two configuration objects for managing the imm service itself:

        safRdn=immManagement,safApp=safImmService
        opensafImm=opensafImm,safApp=safImmService

The first one is the SAF defined configuration object for IMM where the only
used attribute is the config attribute:

        saImmRepositoryInit

used for managing enablement of PBE. The second one is the OpenSAF defined
configuration object for IMM where the config attributes are:

        opensafImmSyncBatchSize
        longDnsAllowed

The IMM OI is normally "hosted" in the PBE. If the PBE is disabled, changes to these
objects are handled by the IMMND.


Allow schema change to add attribute default (4.5)
==================================================
http://sourceforge.net/p/opensaf/tickets/895

The restriction of not allowing a default value to be added to an attribute definition
that previously had no default, has been removed. Only new instances of the class will
get the default assigned when no value is provided for the attribute at object-create
time. Old instances with a null-value for the attribute will still have a null-value
for that attribute even after the schema change. However, a cluster restart will
cause all instances that used to have a null value to get the default value.

A general rule for schema changes is that the immsv never alters the value of existing
attributes as part of a schema change. Doing so would require the OI to be notified,
which is not realistic since the shcema change is not performed as a CCB.
This new feature is only available after an upgrade to OpensAF 4.5 has completed.


Support for configurable OI callback timeout (4.5)
=================================================
http://sourceforge.net/p/opensaf/tickets/16/

A new environment variable IMMA_OI_CALLBACK_TIMEOUT is recognized by the OI library.
In the same way as for the existing IMMA_SYNCR_TIMEOUT, this environment variable
is sampled by the SaImmOiInitialize function for initializing an oi-handle.

The OI-handle will have that timeout associated with it for the rest of its lifetime,
for the server side monitoring of callbacks generated over the handle.

The unit used for the value is seconds. 

Different OI handles can have different callback timeouts, by changing the value of
IMMA_OI_CALLBACK_TIMEOUT prior to each saImmOiIntitialize.

If the environment variable is not defined or is set to less than the default OI 
timeout, then the default OI timeout defined in the server will be used by the server
when monitoring callbacks to this OI. Currently the default OI callback timeout is 
defined to be 6 seconds. It is normally not recommended to set an OI callback timeout
to a value higher than the om/oi-client side timeout for synchronous downcalls.

IMMA_OI_CALLBACK_TIMEOUT is not applicable to admin operations.


SaDoubleT and SaFloatT attributes handled correctly (4.5)
=========================================================
http://sourceforge.net/p/opensaf/tickets/53/
See ticket for details.


Auto relase of lingering search handles  (4.5)
==============================================
http://sourceforge.net/p/opensaf/tickets/47/
See ticket for details.

AdminOp on immsv for dumping resource utilization data (4.5)
===========================================================
http://sourceforge.net/p/opensaf/tickets/35/

This enhancement is mainly intended to assist the maintainers
of OpenSAF in troubleshouting resource/performance issues.
It is not intended to be an end-user utility.

See: osaf/services/saf/immsv/README.RESOURCE_DISPLAY for details.

#938 IMM Access control (4.5)
=============================
http://sourceforge.net/p/opensaf/tickets/938/
OpenSAF 4.5 adds the immsv enhancement of supporting access control of imma clients.

See: osaf/services/saf/immsv/README.ACCESS_CONTROL for details.


Notes on upgrading from OpenSAF 4.[1,2,3,4] to OpenSAF (4.5)
==========================================================
Several enhancements in OpenSAF4.5 add new message types or add new imm server states
for ccb handling (#798,  #799, #16, #895). During a rolling upgrade from an earlier OpenSAF
release to the 4.5 release there will be nodes executing the older release concurrently
with nodes executing OpenSAF 4.5. Nodes executing the earlier release will not
recognize new message types originating from nodes executing 4.5 and messages from
nodes executing the old release may interfere with the extended state machine for ccbs
in new 4.5 nodes.

Because of this upgrade issue, the older more restrictive behavior is still enforced
in OpenSAF 4.5 unless a flag is toggled on in the opensafImmNostdFlags runtime
attribute in the object: opensafImm=opensafImm,safApp=safImmService.
The following is the shell command:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:16 \
           opensafImm=opensafImm,safApp=safImmService

This will set bit 5 of the 'opensafImmNostdFlags' runtime attribute inside the immsv.
Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

has the meaning of 'flags-ON'. Operation-id '2' has the meaning of 'flags-OFF'.
This flag (and possibly other relevant flags) needs to be toggled ON when the upgrade
to OpenSAF 4.5 has been successfully completed. This would be in some final step of
the upgrade. Any cluster start/restart of an OpenSAF4.5 system will always
automatically toggle on relevant flags. 

In summary:

Bit 1 controls schema (imm class) changes allowed or not (normally off/0).
Bit 2 controls OpenSAF4.1 protocols allowed or not (normally on/1).
Bit 3 controls OpenSAF4.3 protocols allowed or not (normally on/1).
Bit 4 controls 2PBE oneSafe2PBE, see 2PBE feature in OpenSAF4.4 above (normally off/0).
Bit 5 controls OpenSAF4.5 protocols allowed or not (normally on/1).

Note also that enhancement #897 described above, added a new config attribute to
the class 'OpensafImm'. An imm xml file containing the extended class definition
for OpensafImm has been added at samples/immsv/OpensafImm_Upgrade_4.5.xml.


Immtools support for saImmOmCcbAbort() and saImmOmCcbValidate() (4.6)
=====================================================================
http://sourceforge.net/p/opensaf/tickets/1200

Immutils was missing wrapper functions for saImmOmCcbValidate and saImmOmCcbAbort.
Immcfg needed a new option (--ccb-validate) for validating created/modified/deleted IMM data.
The option is only available in explicit commit mode.


Cached RTAs show latest cached value when OI is transiently detached (4.6)
==========================================================================
http://sourceforge.net/p/opensaf/tickets/1156

OM clients performing a read (iteration or accessor-get) that fetches a cached
runtime attribute, will not immediately see the attribute as empty when/if the
OI detaches. Instead for a period of grace for 6 seconds, the latest set value is shown.
This allows for failover or switchover or process restart of OI to occur without OM
clients seeing the "glitch" in the value of the cached runtime attribute. 


immdump: Support for dumping instances of selected classes (4.6)
================================================================
http://sourceforge.net/p/opensaf/tickets/927

The immdump tool by default dumps the entire imm database to a file
(either imm-xml format or imm-sqlite format). There is a need for
performing more selective dumping. This enhancement adds support
in immdump for accepting a list of classes in the argument list and to
selectively dump only the instances that belong to classes in that list.


OiRtObject operations with no implementer set should return BAD_OPERATION (4.6)
================================================================================
http://sourceforge.net/p/opensaf/tickets/1064

It used to be the case that if a process/OI:

1) Initializes an IMM-OI handle.
2) Has not set any implementer-name, i.e. has not yet (?) become any identifiable OI.
3) Tries to use the oi-handle to create/delete/update runtime data.

Then the resulting error code returned was ERR_BAD_HANDLE.
This is actually according to the SAF spec. But that error code is here both 
inconvenient and (we claim) a spec error.

It is a spec error because ERR_BAD_HANDLE should at least mean that the handle as
such is bad, i.e. unusable for whatever reason. That is the literal meaning of the
error ERR_BAD_HANDLE. The correct handling of this error is to allocate a new handle,
or abandon whatever task was intending to use the handle.

But in this error case discussed here the handle is actually not invalid and
can even be used after the above scenario happens to invoke saImmOiImplementerSet
to associate an implementer-name with the handle. The missing implementerSet is
an error of handle state, not an error of handle validity. The correct error code
for this case is instead declared to be ERR_BAD_OPERATION:

 ERR_BAD_OPERATION - The targeted object is not implemented by the invoking process.

The SAF text for this case self contradicting:

  The handle immOiHandle is invalid, since it is corrupted, uninitialized,
  has already been finalized, or is not associated with an implementer name.

The last clause 'not associated with an implementer-name' is a VALID state
for an OI handle that has been initialized but not yet associated with an
implementer-name! That is in fact the state of the handle demanded by
saImmOiImplementerSet! So it is not the handle that is invalid, but the
state of the (valid) handle that is not (yet) appropriate for RT operations.

The error code BAD_OPERATION is defined for similar cases for saImOiRtObjectUpdate
and saImmOiRtObjectDelete. Unfortunately SAF did not specify that error code for
saImmOiRtObjectCreate. So this will be a new error code for saImmOiRtObjectCreate.

Fortunately there is not any backwards compatibility issue for this change and 
addition of error code. The error case is an interface-violation, by definition
a surprise for the user/application. So it is actually acceptable, even desirable
(fail fast) for the client process to crash when this happens, since the client
process definitely has a bug.

An addition will be made to the "non compliance" section of the IMMSV_PR to make
this clear.

This new behavior is benign and better than the old behavior. It will of course
be an unexpected error code for the application/user. But since this is an interface
violation (user/programmer error) the error case itself is unexpected.


Immnd timeout on CCB-OI upcall resets client handle (4.6)
========================================================
http://sourceforge.net/p/opensaf/tickets/57

Any IMM API synchronous downcall uses an imm-handle. For the duration of that downcall
the imm-handle will be blocked for usage by other threads. The blocking is handled
by rejecting any such overlapped use with an error. This is to prevent multiple threads
from overlapping use of an imm-handle, which is not allowed for the OpenSAF IMM.
If different threads have a concurrent need for imm access, they must allocate separate
imm-handles.

The blocking of the handle is resolved by either:

    a) an explicit reply from the server for that request (the normal case).
    b) timeout in the client library for that request (default is 10 seconds).
    c) timeout in the server on processing delegated to an OI (default is 6 seconds).

If case (b) happens, the handle will get unblocked on the client side. But subsequent
use by the client could still block on case (c) in the server unless the server side
has resolved the request, either by normal completion or timeout (c). Note that the
normal completion result would in that case not have reached the client.

Thus the case of (c) can be resolved in the server either by the OI replying or by the
immnd-server time-out for continuations. The latter will also clean up continuations
for crashed or hung OIs.

For admin-operation continuations and for search-request-continuations (pure RTA fetch)
this cleanup is already working. So if (c) occurred or (b) and (c) then a subsequent
new request would function normally for these requests (admin-operations and searches).

But for CCB-operation requests, a timeout in the immnd server (case c) will simply abort
the CCB in the server and not clear the handle on the server side. This leaves the handle
effectively stale for the client. The next attempt by the client to use that handle will
result in ERR_BAD_HANDLE. The client then has to initialize a new handle. While that is
an expected error case, this error is actually not necessary in this case, but results
from a simplified design in the server. This is the issue that this enhancement resolves.

This enhancement improves the cleanup of CCB-operation continuations at OI timeout.
The fix should also result in a ccb related error reaching the client, instead of the
ambiguous ERR_TIMEOUT. An OI timeout on a ccb callback will always abort the CCB in
the server, so any reply forwarded towards the OM CCB client should be an 
ERR_FAILED_OPERATION. Such a timeout triggered ccb abort will either be sent all the
way to the client, if the client-side timeout is longer than the server timeout.
Or (when the client has already timed out in the library) be discarded by MDS.
In either case, a subsequent attempt by the client to use the handle should work,
ï.e. not result in ERR_BAD_HANDLE. 

The main points are (a) that the handle gets cleared in the server when
the continuation times out in the server; and (b) that the CCB OM client
receives an error reply when that om client has NOT also timed out.


Improve error diagnostics when PBE is misconfigured (4.6)
=========================================================
http://sourceforge.net/p/opensaf/tickets/1139

Configuration mistakes such as omitting to change immnd.conf to allow PBE
tends to cause strange behavior that is not immediately apparent as to
its cause. Symptoms observed where: 

One could attempt to enable PBE by setting  saImmRepositoryInit to 1:

     sudo immcfg -a saImmRepositoryInit=1 safRdn=immManagement,safApp=safImmService

Yet the PBE process does not start and no clear error message was logged.
One could attempt to disable PBE by setting saImmRepositoryInit back to 2:

    sudo immcfg -a saImmRepositoryInit=2 safRdn=immManagement,safApp=safImmService
    error - saImmOmCcbObjectModify_2 FAILED: SA_AIS_ERR_TRY_AGAIN (6)
    error - immcfg command timed out (alarm)

In the syslog only this was visible:

   Sep 26 09:15:27 NO Precheck of fevs message of type <33> failed with ERROR:18

Error logging been improved and the imm server returns an error string message for the above
Ccb operation error cases. This should make troubleshooting this issue much faster and easier.


IMM API that replaces SaNameT with SaStringT and SA_IMM_ATTR_DN (4.6)
=====================================================================
http://sourceforge.net/p/opensaf/tickets/643

See: osaf/services/saf/immsv/README.SASTRINGT_API for details.


Notes on upgrading from OpenSAF 4.[1,2,3,4,5] to OpenSAF (4.6)
==============================================================
OpenSAF4.6 adds new message types that avoid using the SaNameT type (#969).
During a rolling upgrade from an earlier OpenSAF release to the 4.6 release there
will be nodes executing the older release concurrently with nodes executing OpenSAF 4.6.
Nodes executing the earlier release will not recognize new message types originating
from nodes executing 4.6 and messages from nodes executing the old release may interfere
with the new states in new 4.6 nodes.

Because of this upgrade issue, the new message types added in OpenSAF 4.6 are not used
unless a flag is toggled on in the opensafImmNostdFlags runtime attribute in the object:

   opensafImm=opensafImm,safApp=safImmService.

The following is the shell command:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:32 \
           opensafImm=opensafImm,safApp=safImmService

This will set bit 6 of the 'opensafImmNostdFlags' runtime attribute inside the immsv.
Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

has the meaning of 'flags-ON'. Operation-id '2' has the meaning of 'flags-OFF'.
This flag (and possibly other relevant flags) needs to be toggled ON when the upgrade
to OpenSAF 4.6 has been successfully completed. This would be in some final step of
the upgrade. Any cluster start/restart of an OpenSAF4.6 system will always
automatically toggle on relevant flags. 

In summary:

Bit 1 controls schema (imm class) changes allowed or not (normally off/0).
Bit 2 controls OpenSAF4.1 protocols allowed or not (normally on/1).
Bit 3 controls OpenSAF4.3 protocols allowed or not (normally on/1).
Bit 4 controls 2PBE oneSafe2PBE, see 2PBE feature in OpenSAF4.4 above (normally off/0).
Bit 5 controls OpenSAF4.5 protocols allowed or not (normally on/1).
Bit 6 controls OpenSAF4.6 protocols allowed or not (normally on/1).


Remove unnecessary detour of accessorGet into ImmModel::searchInitialize (4.7)
==============================================================================
http://sourceforge.net/p/opensaf/tickets/674/

A minor enhancement that refactored some code in ImmModell:accessorGet and 
ImmModel::searchInitialize.


immcfg should support ccbObjModify after ccbObjCreate in same ccb (4.7)
=======================================================================
http://sourceforge.net/p/opensaf/tickets/1283

In "explicit commit mode" the immcfg command allows a user to build
up multi-operation CCBs. The IMM API in general allows a CCB to have
an object create operation later followed by an object modify operation
on the object that was created in the same CCB. But due to a limitation
in the implementation of the immcfg command/tool this sequence was not
supported by immcfg. This enhancement removed that limitation.


Abort non-critical CCBs when implementer is disconnected (4.7)
==============================================================
http://sourceforge.net/p/opensaf/tickets/1391

During the buildup of a CCB, i.e. a CCB where the OM client has successfully
added one or more operations to the CCB, but then the OM client lingers or
performs some other task not related to the open CCB; if an OI involved in
the open and idle CCB detaches, then the CCB is doomed to be aborted. Only
when the OM client invoked the next request was the abort of the CCB processed.

One problem with this was that a restart of the detached OI would have to wait
for the CCB to get aborted before it could attach, which could mean waiting
indefinitely on some oblivious om-client to act.

This enhancement fixes so that instead of having to wait for the OM client to
trigger the abort and cleanup of the CCB when it invokes the next operation,
the imm server can immediately process the abort as triggered by the OI detach.


Periodically audit the PBE imm.db file (4.7)
============================================
http://sourceforge.net/p/opensaf/tickets/19/

A first and very limited form of PBE file audit has been implemented in 
OpenSAF 4.7. This due to a serious incident with reference attributes that
have the NO_DANGLING flag set. See critical ticket #1377.

In principle the audit function can and should be extended to run periodically
as a background job and to cover more consistency checks. In the lack of any
pro-active driver, it should at least be extended as a side effect of any future
actual incidents/cases with inconsistency in the persistent imm data that
actually does occur.


Don't check for pending fevs when only updating pure runtime attributes (4.7)
=============================================================================
http://sourceforge.net/p/opensaf/tickets/1445

The IMMND server process has a flow control mechanism to prevent the
IMMNDs (one at each processor of the cluster) to overload the single active
IMMD at the active SC with fevs requests. The message type used when an OI
updates its runtime attributes is conditionally a fevs message. It will become
a fevs message for the normal case of the OI updating a cached runtime 
attribute. But when the OI is updating a pure (non cached) runtime attribute
as a side effect of a processor local OM read request on this attribute, then
the update of the attribute is actually only done locally and is not sent
over fevs. Despite this the update of a pure and local runtime attribute 
followed the same code path and ended up being pushed back with TRY_AGAIN
towards the OI, if fevs traffic was heavy. This push back (flow control) was
in this case totally unnecessary since this variant of the runtime attribute
update message would not be sent over fevs. This potential and unnecessary
delay of an update of a pure runtime attribute has been removed by this
enhancement.


Provide an admin-operation for aborting all non-critical CCBs (4.7)
===================================================================
http://sourceforge.net/p/opensaf/tickets/1107

There may arise situations where an open CCB that is not in critical,
i.e. has not entered the commit protocol yet, is blocking an involved
service/OI from performing some other task that is more urgent and more
important than completing that CCB. If the OM client is idling and the 
built up CCB is so far well formed (accepted by involved OIs) then the
OM client can linger indefinitely, particularly a human operator.

A good example where a more urgent task may be blocked is the AMF, where
an si-swap will fail and cause the standby to reboot if it was involved
in an open CCB when the si-swap order was issued (see ticket #1105).
Ticket #1105 can be fixed by the AMF (active or standby) sending this
admin-operation directed at the IMM service requesting it to abort non
critical CCBs. The AMF can either use a synchronous admin-op or an 
asynchronous admin-op. After the admin-operation has been invoked the AMF 
should allow a few seconds for the CCB to get aborted and the AMF OI to
get the abort callback for the CCB. That should then clear the path for
the AMF standby to succeed with the si-swap. 

The admin-operation for aborting non critical CCBs involves requesting the
operation id '202' directed at the IMM SF service object:

	immadm -o 202 safRdn=immManagement,safApp=safImmService


Use error string to classify cause for aborted CCB.(4.7)
========================================================
http://sourceforge.net/p/opensaf/tickets/744/

For the case of a ccb-operation resulting in the return of:

    SA_AIS_ERR_FAILED_OPERATION

which means the CCB has been aborted, there is a need for some clients
to discriminate between the two possible generic categories of abort:

	Validation-abort.
or
	Resource-abort.

A validation-abort is the result when the operations added by the OM-client to
the CCB constitute an *invalid* set of operations according to either
fundamental rules enforced by the IMM service or model specific rules enforced
by the involved Ois relative to the *current* state of the database.

A resource-abort is the result if there is a resource problem somewhere in the 
system such that the CCB can not be committed or further processed at this time.
There are many kinds of resource aborts. A few examples would be:

      Ccb is aborted because it interferes with another operation in the system.
      Ccb is aborted due to loss of contact with some involved OI.
      Ccb is aborted due to loss of contact with PBE before apply request.
      Ccb is aborted because an OI reports that it has insufficient resources.

Note that SA_AIS_ERR_FAILED_OPERATION is the *only* error code with the meaning
that the CCB has been aborted. The fact that the CCB has been aborted is the
dominating issue/fact that must be understood and coped with by any and all
applications using the CCB interface. The further discrimination into validation
abort or resource abort is only relevant for *some* applications that are capable
of handling the abort differently depending on this discrimination.

The fundamental logical difference between validation abort and resource abort
is that a validation abort is due to the CCB being incorrectly formed by the
OM-client; while a resource abort is due to problems in the server or OIs
making it "physically" impossible to successfully commit this CCB even though
it *may* be a correctly formed CCB.

The possible actionable difference for the OM client between the two abort
categories is that a replay by the OM client of a resource aborted CCB could
succeed. This would be the case if the resource problem has been resolved. But
a replay by the client of a validation aborted CCB will never succeed, except
for some rare cases where another CCB was interleaved and altered the database
in such a way as to *make* the replay suddenly become a valid change relative
to a *new* state. This latter case should be so rare as to be ignored.

So the bottom line is that some applications may wish to determine if an
aborted CCB that is replayed will have some chance of successfully comitting.
The application can do this by obtaining the abort category.

This enhancement makes it possible for an application or end-user to obtain the
abort category. The abort category is prepended as a string prefix to one or more
error strings returned by saImmOmCcbGetErrorStrings().

A validation aborted CCB will have an error string prefixed with:

             "IMM: Validation abort:"

A resource aborted CCB will have an error string prefixed with:

              "IMM: Resource abort:"

The prefix provides both a readable tag for human end-users and a standardized
prefix that may be string-matched in a program or script.

Finally there are some subtle issues that should be understood by applications
intending to discriminate between resource abort and validation abort.

a) A Ccb may be aborted for more than one reason. Thus a Ccb that is actually
not a valid Ccb (absolutely or relative to current IMM state) may run into a
resource problem during buildup and thus be aborted as a resource abort before
it had the chance to be evaluated for validity.

b) There may be more than one OI involved in a Ccb. Some OIs may reply OK
on validation (completed callback), some OIs may reply with validation 
error, and some OIs may reply with resource error or default on timeout
resulting in resource error. The end result is that if there is one validation
error "vote" then that will dominate the resulting abort category.

c) Validation success or failure often depends on the current state. i.e. 
the state of the set of involved objects *before* the attempted Ccb. Such a
state may be changed by some other client applying its own Ccb. So a Ccb
that is aborted with validation error, may later succeed due to the changed
prior state. But the assumption here is that the two Ccb clients are not
communicating with each other and so this possible case should be ignored
by the application. 

d) There is never any general guarantee that a Ccb that is replayed after a
resource abort will "sooner or later" be validated successfully and commit.
Thus any loop that replays a Ccb on resource abort should still limit the
number of retries.

e) All error strings generated by the IMM service are prefixed with "IMM:"
The prefix means that the OM client can recognize error strings generated by
the IMM service as distinct from error strings generated by an OI.

f) For the case where there is no error string or no prefixed error string,
the application may assume that it is a resource abort. 

g) If the error strings contain prefixes for both validationabort and resource
abort, then validation abort dominates.


Add attribute definition flag SA_IMM_ATTR_DEFAULT_REMOVED (4.7)
===============================================================
http://sourceforge.net/p/opensaf/tickets/1471

Support for removing a default value from an attribute definition in a class
definition has now been added. This kind of upgrade was not allowed previously
since it is inherently a case of non backwards compatibility and can cause
problems for legacy applications/users expecting and relying on the default.
That is after all the entire point of having a default.

This enhancement removes the restriction of not allowing the removal of a
default value if this new flag is set. The effect of this flag is that
when/if an object of the class is created with no value assigned to the
attribute that used to have a default but no longer has a default; then a
trace message is generated noting that this attribute used to have a default
but no longer has a default and will in this case have no value.

This is to assist users or troubleshooters if they get some form of problem
by the removal of the default. The trace message should speed up
troubleshooting and prevent the creation of unnecessary tickets or trouble
reports.


Sync data Mbcsv check pointing can be optimized (4.7)
=====================================================
http://sourceforge.net/p/opensaf/tickets/952/

Imm sync messages can be large. They are sent over fevs. Fevs messages are
handled by the active IMMD by MDS broadcasting them to all IMMNDs. Before
doing the broadcast, the active IMMD uses the message based checkpoint 
service Mbcsv, to checkpoint each fevs message to the standby IMMD. This is
to secure that a failover or switchover of SC/IMMD will not cause any gap
in the fevs count for the fevs broadcasts. But if a failover actually happens
during a sync, then the new active IMMD will abort the sync. There is then
no point in ever re-broadcasting the contents of a sync message. The only
thing that needs to be re-broadcast is the fevs message header to close any
gap in the fevs count. This enhancement truncates the sync mesasages to only
contain the fevs header, before they are checkpointed to the standby IMMD.
This speeds up the sync and removes some communication load.


PBE: imm.db.XXXXXX temp files should managed in pbe subdirectory (4.7)
======================================================================
http://sourceforge.net/p/opensaf/tickets/896/

The PBE generates the imm.db file in what should be a local tmp directory.
This is set by the configuration variable IMMSV_PBE_TMP_DIR in the immnd.conf
configuration file. By default it is /tmp.

This enhancement of PBE creates a sub-directory to IMMSV_PBE_TMP_DIR where all
temporary PBE files are created. This will reduce the risk of interference with
other services and applications sharing the tmp directory. It also facilitates
the safe cleanup of all such temporary files by a PBE that is restarted.


PBE: Detach of PBE should abort all non-critical and non-empty CCBs (4.7)
=========================================================================
http://sourceforge.net/p/opensaf/tickets/1261/

This enhancement is related to defect ticket [#1260].

If the PBE detaches while there are any active non-critical and non-empty CCBs,
then such CCBs should be ABORTED, i.e. prevented from being further processed.

The abort must be done when the detach arrives over fevs. It must NOT be done
when the initial IMMND local PBE detach occurs, since that would make the ccb
state deviate locally.


Make it possible to run valgrind on osafimmnd when PBE is enabled (4.7)
=======================================================================
http://sourceforge.net/p/opensaf/tickets/1496/

A minor enhancement removing an obstacle to executing the IMMND process under
valgrind when PBE is enabled.

Notes on upgrading from OpenSAF 4.[1,2,3,4,5,6] to OpenSAF (4.7)
================================================================
OpenSAF4.7 adds new attribute flag allowing the removal of a default value
definitions (#1471). During a rolling upgrade from an earlier OpenSAF release
to the 4.7 release there will be nodes executing the older release concurrently
with nodes executing OpenSAF 4.7. Nodes executing the earlier release will not
recognize the new attribute flag originating from nodes executing 4.7.

Because of this upgrade issue, the new attribute flag added in OpenSAF 4.7 is 
not allowed unless a flag is toggled on in the opensafImmNostdFlags runtime
attribute in the object:

   opensafImm=opensafImm,safApp=safImmService.

The following is the shell command:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:64 \
           opensafImm=opensafImm,safApp=safImmService

This will set bit 7 of the 'opensafImmNostdFlags' runtime attribute inside the immsv.
Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

has the meaning of 'flags-ON'. Operation-id '2' has the meaning of 'flags-OFF'.
This flag (and possibly other relevant flags) needs to be toggled ON when the upgrade
to OpenSAF 4.7 has been successfully completed. This would be in some final step of
the upgrade. Any cluster start/restart of an OpenSAF4.7 system will always
automatically toggle on relevant flags. 

In summary:

Bit 1 controls schema (imm class) changes allowed or not (normally off/0).
Bit 2 controls OpenSAF4.1 protocols allowed or not (normally on/1).
Bit 3 controls OpenSAF4.3 protocols allowed or not (normally on/1).
Bit 4 controls 2PBE oneSafe2PBE, see 2PBE feature in OpenSAF4.4 above (normally off/0).
Bit 5 controls OpenSAF4.5 protocols allowed or not (normally on/1).
Bit 6 controls OpenSAF4.6 protocols allowed or not (normally on/1).
Bit 7 controls OpenSAF4.7 protocols allowed or not (normally on/1).


Safe-read (transactional read) (5.0)
=============================================
http://sourceforge.net/p/opensaf/tickets/48/

Adds support for an OM CCB client to read-access a config object transactionally.
The API works exactly the same way as saImmOmAccessorGet, except that

   a) The API takes a SaImmCcbHandleT instead of a SaImmAccessorHandleT

   b) The values returned for the objects config attributes are from a version
      of the object consistent with the CCB/transaction. This means either the
      latest applied version or a newer version created in the same CCB but
      not yet applied. 

   c) Access to an object that has been deleted in the same CCB but not applied
      is rejected with ERR_NOT_EXIST. 

   d) Access to an object that has been created in the same CCB but not applied
      is allowed, providing the latest version of the config attributes in that CCB.

   e) Safe read is not allowed using a runtime object as target.

Runtime attributes residing in a config object are handled exactly the same as for
saImmOmAccessorGet. The reason a safe-read call is not allowed on a runtime *object*
is that a runtime object *only* contains runtime attributes. Performing a safe-read
on a runtime object makes no sense. 


saImmOmCcbObjectRead(SaImmCcbHandleT ccbHandle, /* in */
                     SaConstStringT objectName, /* in */
                     const SaImmAttrNameT *attributeNames, /* in */
                     SaImmAttrValuesT_2 ***attributes); /* out */


Return Values :   SA_AIS_ERR_BUSY - The object targeted by the request is already
                  the target of conflicting/exclusive operation in another CCB.
                  The conflicting operation would be a modify or delete.

                  SA_AIS_ERR_INVALID_PARAM - The objectName parameter identifies a
                  runtime object.

                  Returncodes otherwise identical to saImmOmAccessorGet.


SC Absence (5.0)
===============================================
https://sourceforge.net/p/opensaf/tickets/1625

SC absence enhancement has the goal of increasing OpenSAFs resilience in 
the face of both active and standby SC going down. Both SCs being absent 
implies that all OpenSAF director services are absent indefinitely, until 
an SC is re-established. Prior to the SC absence enhancement, departure 
of both SCs always resulted in a cluster restart. With the SC Absence 
enhancement, payloads continue to provide reduced and limited service 
until an SC-active is re-established. For the IMM service, SC absence is 
configured by uncommenting the environment variable IMMSV_SC_ABSENCE_ALLOWED.

export IMMSV_SC_ABSENCE_ALLOWED=900

Value of environment variable IMMSV_SC_ABSENCE_ALLOWED is stored in 
scAbsenceAllowed attribute in opensafImm=opensafImm,safApp=safImmService
object. This value is used by AMF to restart the cluster if SC absence
is longer than the value in scAbsenceAllowed attribute in seconds.

Support for SC absence is incompatible with 2PBE. If both are configured
then 2PBE will win and the SC absence feature will be ignored. An error
message is printed in this case to the syslog at startup. Allowing SC absence
feature is a configuration choice impacting all OpenSAF services, not just 
the IMM service. If it is to be allowed then it is not sufficient to only 
configure the IMM service for SC absence. The level of service that is 
provided during absent SC depends on the particular service. In the case 
of the IMM service, the service provided during SC absence is in essence 
only the reading of config data.

See: osaf/services/saf/immsv/README.SC_ABSENCE for details.


Add attribute definition flag SA_IMM_ATTR_STRONG_DEFAULT (5.0)
===============================================================
https://sourceforge.net/p/opensaf/tickets/1425

The default value is only effective for object creation, and not later
in the life cycle of the object. This makes the default attribute value
mechanism weaker than some users would like.

When there is an attempt to set empty value to or to delete all values from
attributes with SA_IMM_ATTR_STRONG_DEFAULT flag, default value will be set.
The SaImmAttrModificationT_2 will be changed to SA_IMM_ATTR_VALUES_REPLACE
with default value and sent to OI.

SA_IMM_ATTR_STRONG_DEFAULT flag can only be set on an attribute definition
that includes default value.

SA_IMM_ATTR_STRONG_DEFAULT flag is supported when OM API registers with
version A.02.17 or higher.


Canonicalize attributes presented by saImmOiCcbObjectModifyCallbackT_2 (5.0)
============================================================================
https://sourceforge.net/p/opensaf/tickets/801
https://sourceforge.net/p/opensaf/tickets/1651

For OIs or appliers receiving ccb-callbacks, the handling of the modify-callback
can be particularly complex. This is due to the modify callback being defined
by SAF as faithfully presenting the same parameters as the originating om-client 
parameters provided over the om-api.

The object modify operation allows for modifications expressed as changes
relative to the current state of attributes. This is of course acted on by
the imm-server resulting in an after-image for the modified object.

The callback to the OI or applier is currently of the same form, in general
requiring the OI/applier to:
 a) know the current state of the attributes of the object or do an for 
    appliers unsafe read 
 b) to correctly compute the transformation as defined by the imm-spec. 
Particularly the later is asking quite a lot for the average OI/applier 
implementer.

Only for the "special applier" is the modify callback currently canonicalized 
to contain simply the replacement values, i.e. the after operation image.

To simplify the task for OI's and appliers in handling modify callbacks,
the modify-callback instead provides the after-modify-operation-image of 
the attributes. The new callback format containing just the replacement value
resulting from the operation must be logically equivalent to the set of all
before-image and operation variants resulting in this replacement value.

Canonicalize attributes are presented by saImmOiCcbObjectModifyCallbackT_2
when IMM OI registers with version A.02.17 or higher.


Class and object applier set are on local node (5.0)
====================================================
https://sourceforge.net/p/opensaf/tickets/1535

The enhancement makes object and class applier set info consistent per node.
This means that applier set will bind objects and classes that have already 
been bound on the local node by the same applier name.

Applier name continues to be shared between nodes, while object and class
applier bindings are kept on the originating node.

IMM Hardcoded limits as config parameters (5.1)
===============================================================
http://sourceforge.net/p/opensaf/tickets/195/

The enhancemnet makes IMM limits configurable. The limits like maxClasses,
maxImplementers, maxAdminowners and maxCcbs are allowed as configurable.
The limits are added as attributes to the imm object 
"opensafImm=opensafImm,safApp=safImmService".

The default values configured for these attributes are :

IMMSV_MAX_CLASSES 1000
IMMSV_MAX_IMPLEMENTERS 3000
IMMSV_MAX_ADMINOWNERS 2000
IMMSV_MAX_CCBS 10000

The user can not configure the values less than the default values.

The value for maxCcbs are the active ccbs present in the cluster.
The terminated CCBs will be removed from the cluster after 5 minutes.
If the number of terminated CCBs are greater than "2 * maxCcbs" then 
CCBs will be removed from the cluster after 2 minutes.

Veteran max timeout is made configurable in case of SC Absence (5.1)
===================================================================
http://sourceforge.net/p/opensaf/tickets/1974/

IMMSV_SC_ABSENCE_VETERAN_MAX_WAIT is the IMMD waits for veteran IMMNDs after 
SC absence. If IMMD processes the intro messages from new IMMNDs before the intro
messages from veteran IMMNDs, IMM service will start to load from file instead of 
syncing data from veteran nodes. The IMMSV_SC_ABSENCE_VETERAN_MAX_WAIT will 
prevent that from happening.

Note that during a fresh cluster startup, IMMD also waits for veteran IMMNDs.
Setting this value to large will slow down the cluster startup. This timeout is 
only used with SC absence enabled. When SC absence is disabled, IMMD will not wait 
for the veteran IMMNDs.

The IMMSV_SC_ABSENCE_VETERAN_MAX_WAIT is present in immd.conf.
The default value (when the environment variable is not set) is 3 seconds.

export IMMSV_SC_ABSENCE_VETERAN_MAX_WAIT=3

immcfg allows admin-owner in explicit commit mode (5.1)
===============================================================
https://sourceforge.net/p/opensaf/tickets/1383/

immcfg in explicit commit mode, will not be able to set adminOwnerName.
This enhancement removes the restriction.

immcfg -o adminOwnerName.

--ccb-apply and --ccb-abort will finalize the admin owner.
if -o option is not specified default admin-owner is considered.

immadm can explicitly set ReleaseOnFinalize (5.1)
=======================================================
https://sourceforge.net/p/opensaf/tickets/1937/

with this enhancement immadm introduces a new flag '-r' for setting ROF (Release On Finalize) flag.
The default value for ROF (when -r option is not specified) is SA_FALSE.

Notes on upgrading to OpenSAF 5.1
================================================================
OpenSAF5.1 makes the IMM attributes as configurable (#195).
During a rolling upgrade from an earlier OpenSAF release to the 5.1 
release there will be nodes executing the older release concurrently.
Nodes executing the earlier release will not recognize the new attributes 
introduced in imm config object from nodes executing 5.0.

Because of this upgrade issue, the new attribute flag added in OpenSAF 5.1 is
not allowed unless a flag is toggled on in the opensafImmNostdFlags runtime
attribute in the object:

   opensafImm=opensafImm,safApp=safImmService.

The following shell command must be used once all nodes are upgraded :

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:256 \
           opensafImm=opensafImm,safApp=safImmService

This will set bit 9 of the 'opensafImmNostdFlags' runtime attribute inside the immsv.
Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

Integrate IMM service with CLM (5.2)
=======================================================
https://sourceforge.net/p/opensaf/tickets/1640/

with this enhancement IMM is integrated with CLM.

The IMM agent has to register with A.02.18 to integrate with CLM and receive 
CLM memebership information of the node. 

The IMMND registers with CLMS and receives notification about the node leaves 
and joins the CLM membership. The CLM membership information will be sent to 
IMM agents which registers with A.02.18.

IMMD is not yet integrated, as the IMMND has to services to clients with lesser versions.
IMMND has to be UP even if the CLM node is down. The IMMD integration has to be done along 
with Enhanced cluster management(#439).

In case of CLM node lock, and HEADLESS is triggered after CLM node lock, then CLM locked 
node is nullified. The node is considered as HEADLESS and all other agent functions 
supported in HEADLESS are supported.

Notes on upgrading to OpenSAF 5.17.11
=====================================
OpenSAF 5.17.11 adds new attribute flag allowing the removal of disconnected
appliers (#2579). During a rolling upgrade from an earlier OpenSAF release
to the 5.17.11 release there will be nodes executing the older release concurrently
with nodes executing OpenSAF 5.17.11. Nodes executing the earlier release will not
recognize the new attribute flag originating from nodes executing 5.17.11.

Because of this upgrade issue, the new attribute flag added in OpenSAF 5.17.11 is
not allowed unless a flag is toggled on in the opensafImmNostdFlags runtime
attribute in the object:

   opensafImm=opensafImm,safApp=safImmService.

The following is the shell command:

        immadm -o 1 -p opensafImmNostdFlags:SA_UINT32_T:1024 \
           opensafImm=opensafImm,safApp=safImmService

This will set bit 10 of the 'opensafImmNostdFlags' runtime attribute inside the immsv.
Operation-id '1' invoked on the object:

 'opensafImm=opensafImm,safApp=safImmService'

has the meaning of 'flags-ON'. Operation-id '2' has the meaning of 'flags-OFF'.
This flag (and possibly other relevant flags) needs to be toggled ON when the upgrade
to OpenSAF 5.17.11 has been successfully completed. This would be in some final step of
the upgrade. Any cluster start/restart of an OpenSAF 5.17.11 system will always
automatically toggle on relevant flags.

An imm xml file containing the extended class definition for OpensafImm has
been added at samples/immsv/OpensafImm_Upgrade_5.17.11.xml.

In summary:

Bit 1 controls schema (imm class) changes allowed or not (normally off/0).
Bit 2 controls OpenSAF4.1 protocols allowed or not (normally on/1).
Bit 3 controls OpenSAF4.3 protocols allowed or not (normally on/1).
Bit 4 controls 2PBE oneSafe2PBE, see 2PBE feature in OpenSAF4.4 above (normally off/0).
Bit 5 controls OpenSAF4.5 protocols allowed or not (normally on/1).
Bit 6 controls OpenSAF4.6 protocols allowed or not (normally on/1).
Bit 7 controls OpenSAF4.7 protocols allowed or not (normally on/1).
Bit 8 controls OpenSAF5.0 protocols allowed or not (normally on/1).
Bit 9 controls OpenSAF5.1 protocols allowed or not (normally on/1).
Bit 10 controls OpenSAF5.17.11 protocols allowed or not (normally on/1).

Removal of disconnected applier (5.17.11)
=================================================
Once an implementer is created, it resides in the system to the cluster
restart. There is no way to remove implementers from the system. Applier is
a special type of implementers and the same feature applies to appliers.

Applier names usually contain the node name where they are created to avoid
the collision with the same appliers on other nodes. In systems where new
nodes come with new names every time they join the cluster, this can be
a problem and the limit of 3000 implementer and appliers can be reached.

The new feature is introduced in 5.17.11 which will handle the time for
keeping disconnected appliers in the system. When the time expires,
disconnected appliers will be removed from the system.

The applier timeout is configurable, and it is set in the new attribute
minApplierTimeout in IMM object. If minApplierTimeout attribute is set to 0,
the removal of disconnected appliers is disabled. The unit in counting
the timeout is in seconds.

With enabling the removal of disconnected appliers, there might be a risk that
some applications in the cluster rely on reattaching appliers. This will not
work if an application tries to reattach appliers after the applier timeout
expires.

To be possible to use this new feature, bit 10 must be set in
opensafImmNostdFlags attribute in IMM object.

----------------------------------------
DEPENDENCIES
============
immsv depends of the following other services:
- NID
- MBCSV
- MDS
- BASE
- AMF
- logtrace
- libxml2
- sqlite3


DATA STRUCTURES

The most important data structures for the IMMD process type are:

 IMMD_CB:               The "control block" for the IMMD, a singleton
 IMMD_IMMND_INFO_NODE:  Information about one IMMND
 IMMD_CB.immnd_tree:    Collection of IMMD_IMMND_INFO_NODEs


The most important data structures for the IMMND process type are:

 IMMND_CB:                              The "control block" for the IMMND, a
                                        singleton
 IMMND_IMM_CLIENT_NODE:                 Information about one client connection
 IMMND_IMM_CLIENT_NODE.client_info_db:  Collection of IMMND_IMM_CLIENT_NODEs
 IMMND_IMM_CLIENT_NDOE.immModel:        Pointer to the core Imm model,
                                        a singleton. The ImmModel code is found
                                        in ImmModel.[hh|cc]

The most important data structures for the IMMA library are:

 IMMA_CB:                       The "control block" for the IMMA, a singleton
 IMMA_CLIENT_NODE:              Information about one OM or OI connection
 IMMA_CB.client_tree:           Collection of IMMA_CLIENT_NODEs
 IMMA_ADMIN_OWNER_NODE:         Information about one admin-owner registration
 IMMA_CB.admin_owner_tree:      Collection of IMMA_ADMIN_OWNER_NODEs
 IMMA_CCB_NODE:                 Information about one initialised CCB
 IMMA_CB.ccb_tree:              Collection of IMMA_CCB_NODEs
 IMMA_SEARCH_NODE:              Information about one initialised search
 IMMA_CB.search_tree:           Collection of IMMA_SEARCH_NODEs
 IMMA_CONTINUATION_RECORD:      Information about one invoked asynchronous
                                admin-op
 IMMA_CB.imma_continuations:    Collection of IMMA_CONTINUATION_RECORDs

Common message types and message layouts are found under
osaf/libs/common/immsv/include in the files immsv_evt.h and immsv_evt_model.h


STATE MACHINES

There are two state machines that control important aspects of the IMMND
behaviour.

The ImmNodeState in immModel.cc governs the accessibility of the data model of
the IMM at each node.

    typedef enum {

        IMM_NODE_UNKNOWN = 0,         /*Initial state */
        IMM_NODE_LOADING = 1,         /* Participating in a cluster restart */
        IMM_NODE_FULLY_AVAILABLE = 2, /* Normal fully available state */
        IMM_NODE_ISOLATED = 3,        /* Trying to join an established cluster*/
        IMM_NODE_W_AVAILABLE = 4,     /* We are being synced, No model reads
                                         allowed */
        IMM_NODE_R_AVAILABLE = 5      /* Write locked while other nodes are
                                         being synced. No model writes allowed*/
    } ImmNodeState;

  Transitions:

    IMM_NODE_UNKNOWN -(StartLoading)-> IMM_NODE_LOADING
    IMM_NODE_LOADING -(LoadingSuccess)->IMM_NODE_FULLY_AVAILABLE
    IMM_NODE_UNKNOWN -(MissedLoading)-> IMM_NODE_ISOLATED
    IMM_NODE_ISOLATED-(StartSync)->IMM_NODE_W_AVAILABLE
    IMM_NODE_W_AVAILABLE-(SyncSuccess)->IMM_NODE_FULLY_AVAILABLE
    IMM_NODE_FULLY_AVAILABLE->(StartSync)->IMM_NODE_R_AVAILABLE
    IMM_NODE_R_AVAILABLE->(SyncTerminate)->IMM_NODE_FULLY_AVAILABLE


The IMMND_SERVER_STATE in immnd_cb.h and immnd_proc.c governs the progress of
cluster level tasks. In particular the behaviour of the coordinator, and
non-coordinators during loading and sync.

    typedef enum immnd_server_state {

        IMM_SERVER_UNKNOWN         = 0, /* Not allowed. Not used */
        IMM_SERVER_ANONYMOUS       = 1, /* Initial state */
        IMM_SERVER_CLUSTER_WAITING = 2, /* Waiting for expected #nodes */
        IMM_SERVER_LOADING_PENDING = 3, /* Waiting for loading to start */
        IMM_SERVER_LOADING_SERVER  = 4, /* Coord is executing loading */
        IMM_SERVER_LOADING_CLIENT  = 5, /* Not coord, receive loading */
        IMM_SERVER_SYNC_PENDING    = 6, /* Not coord, load impossible, wait for
                                           sync*/
        IMM_SERVER_SYNC_CLIENT     = 7, /* Not coord, this node is being
                                           synced */
        IMM_SERVER_SYNC_SERVER     = 8, /* Coord, executing sync */
        IMM_SERVER_DUMP            = 9, /* Not used */
        IMM_SERVER_READY           = 10 /* Coord & Not coord. Normal idle
                                           state.*/

    }IMMND_SERVER_STATE;

  Transitions:

    IMM_SERVER_ANONYMOUS-(IMMD is up, intro sent)->IMM_SERVER_CLUSTER_WAITING
    IMM_SERVER_CLUSTER_WAITING-(requisite nodes, timeout)->
                                                      IMM_SERVER_LOADING_PENDING
    IMM_SERVER_LOADING_PENDING-(coord and loading possible)->
                                                       IMM_SERVER_LOADING_SERVER
    IMM_SERVER_LOADING_PENDING-(non coord and loading possible)->
                                                       IMM_SERVER_LOADING_CLIENT
    IMM_SERVER_LOADING_PENDING-(non coord and loading impossible)->
                                                         IMM_SERVER_SYNC_PENDING
    IMM_SERVER_LOADING_SERVER-(loading succeeded)->IMM_SERVER_READY
    IMM_SERVER_LOADING_CLIENT-(loading succeeded)->IMM_SERVER_READY
    IMM_SERVER_SYNC_PENDING-(sync request accepted)->IMM_SERVER_SYNC_CLIENT
    IMM_SERVER_READY-(coord and accept sync request)->IMM_SERVER_SYNC_SERVER
    IMM_SERVER_SYNC_CLIENT-(sync succeeded)->IMM_SERVER_READY
    IMM_SERVER_SYNC_SERVER-(sync terminated)->IMM_SERVER_READY


OTHER IMPLEMENTATION POINTS

There is an epoch-count maintained by the IMMD. The epoch count is incremented
cluster-wide by the coordinator after important events such as: loading
completed, sync completed and dump completed. The epoch count is stored
persistently in every dump so that a re-load using that dump will be starting
from the saved epoch.

The central data model of the IMMND is implemented in C++ and uses STL (Standard
Template Library) collections to represent the data model.
Other parts of IMMND are implemented in C.

The immload and immdump programs are implemented in C++. These programs
communicate with the IMMSv using the IMM-OM API. They use libxml2 to parse and
generate the imm.xml format.

The IMMA library is implemented in C.

The IMMD is implemented in C.



CONFIGURATION

See OpenSAF_IMMSv_PR.

COMMAND LINE INTERFACE

See OpenSAF_IMMSv_PR.

DEBUG

To enable/disable immd/immnd trace in a running system, send signal USR2 to the
immd/immnd process. Each signal toggles the trace.
Trace default is disabled.

Traces are written to the file configured in immd.conf and immnd.conf.
Traces are always stored in $PKGLOGDIR directory and the directory component
of the path name (if any) is ignored.

To enable traces from the very start, uncomment:

        #args="--tracemask=0xffffffff"

in immd.conf/immnd.conf and restart the cluster.

Errors, warnings and notice level messages are logged to the syslog.

To enable traces in the IMM library, export the variable IMMA_TRACE_PATHNAME
with a valid pathname before starting the application using the IMM library.

For example:

$ export IMMA_TRACE_PATHNAME=imm.trace
$ ./immomtest
$ cat $pkglogdir/imm.trace


It is also possible to trace slave processes forked by the IMMND.
This would be processes for loading, sync and dump/pbe.
To enable such trace uncomment:

#export IMMSV_TRACE_PATHNAME=osafimmnd

It is recommended to use osaflog command as it takes care of flushing
unwritten trace messages from memory to disk, as well as concatenating
the pieces that may have resulted from log rotation of the trace stream.

TEST

Currently a "tetware like" test suite can be found in 'tests/immsv/'.
See tests/immsv/README for instructions.


TODO

- Revisit MDS reliability, implement FEVS re-send by IMMD.
- Implement version handling for MDS messages.
- Revisit escalation problem.
- Cleanup "TODO" comments
- Revisit trace statements, cleanup
See:
	 http://devel.opensaf.org/report


CONTRIBUTORS/MAINTAINERS

Anders Bjornerstedt <Anders.Bjornerstedt@ericsson.com>
Hans Feldt <Hans.Feldt@ericsson.com>
Peter Strand <peter.strand@ericsson.com>
Mahesh Alla <mahesh.valla@oracle.com>
Neelakanta Reddy <reddy.neelakanta@oracle.com>
Zoran Millinkovic <zoran.milinkovic@ericsson.com>

The IMM service OpenSAF framework was originally cloned from the OpenSAF
check-point service.
